{
  "schema_name": "tutor_asset.explain.v1",
  "version": "1.0",
  "topic": "linearsearch",
  "lang": "fa",
  "mode": "explain",
  "title": "Linear Search (جستجوی خطی) — FIAE Explain Core v1.0",
  "summary": "**Linear Search (جستجوی خطی)** ساده‌ترین الگوریتم جستجو است که یک آرایه را **به‌صورت ترتیبی** از ابتدا تا انتها می‌گردد و هر عنصر را با مقدار جستجو شده مقایسه می‌کند.\n\n**هدف:** یک عنصر مشخص `x` را در آرایه پیدا کردن و اندیس آن را برگرداندن؛ اگر وجود نداشته باشد، معمولاً `-1` برمی‌گرداند.\n\n**نکته کلیدی (امتحانی):** هیچ مرتب‌سازی قبلی لازم نیست؛ روی **هر** آرایه‌ای (مرتب/نامرتب) کار می‌کند، اما در بدترین حالت **O(n)** زمان نیاز دارد.",
  "blocks": [
    {
      "kind": "definition",
      "text": "**Linear Search (جستجوی خطی)** ساده‌ترین الگوریتم جستجو است که یک آرایه را **به‌صورت ترتیبی** از ابتدا تا انتها می‌گردد و هر عنصر را با مقدار جستجو شده مقایسه می‌کند.\n\n**هدف:** یک عنصر مشخص `x` را در آرایه پیدا کردن و اندیس آن را برگرداندن؛ اگر وجود نداشته باشد، معمولاً `-1` برمی‌گرداند.\n\n**نکته کلیدی (امتحانی):** هیچ مرتب‌سازی قبلی لازم نیست؛ روی **هر** آرایه‌ای (مرتب/نامرتب) کار می‌کند، اما در بدترین حالت **O(n)** زمان نیاز دارد.\n"
    },
    {
      "kind": "idea",
      "text": "**تشبیه:** مثل وقتی یک کتاب را صفحه‌به‌صفحه ورق می‌زنی تا یک کلمه‌ی خاص را پیدا کنی.\n\n- از اندیس `0` شروع کن\n- عنصر‌به‌عنصر با مقدار جستجو شده `x` مقایسه کن\n- به‌محض `arr[i] == x`: توقف → برگرداندن `i`\n- اگر به انتها رسیدی و پیدا نشد: برگرداندن `-1`\n\n**تصویر ذهنی:** Linear Search همان روش «زور سنجی» برای جستجو است – همیشه درست، اما نه همیشه سریع.\n"
    },
    {
      "kind": "procedure",
      "text": "**گام ۱: مقداردهی اولیه**\n- طول آرایه `n` را مشخص کن\n- از اندیس `i = 0` شروع کن\n\n**گام ۲: حلقه**\n- از موقعیت `0` تا `n-1` حرکت کن\n- برای هر اندیس `i`: `arr[i]` را با `x` مقایسه کن\n\n**گام ۳: تطابق؟**\n- اگر `arr[i] == x`: **توقف فوری** → برگرداندن `i`\n- وگرنه: ادامه به اندیس بعدی\n\n**گام ۴: بدون تطابق**\n- اگر کل حلقه بدون تطابق تمام شد: برگرداندن `-1`\n\n**نکته‌ی امتحانی:** Linear Search توقف زودهنگام دارد (Best-Case O(1))، اما **هیچ مزیتی** از مرتب‌سازی قبلی ندارد (برخلاف Binary Search).\n"
    },
    {
      "kind": "example",
      "text": "????: ???????? `x=22` ?? `[64,25,12,22,11]` ? ????? 3.\n"
    },
    {
      "kind": "complexity",
      "text": "**زمان (Time):**\n- **بهترین حالت:** `O(1)` – عنصر در موقعیت اول است\n- **حالت میانگین:** `O(n/2)` ⇒ ساده‌سازی شده: `O(n)`\n- **بدترین حالت:** `O(n)` – عنصر در انتها است یا وجود ندارد\n\n**حافظه (Space):**\n- `O(1)` – فقط متغیر حلقه `i` لازم است\n\n**مقایسه‌ها:**\n- حداقل: 1 (بهترین حالت)\n- حداکثر: n (بدترین حالت)\n- میانگین: n/2\n\n**پایداری (Stability):**\n- مربوط نیست (جستجو، نه مرتب‌سازی)\n\n**زمینه‌ی امتحانی:**\n- ساده‌ترین الگوریتم برای داده‌های **نامرتب**\n- مقایسه با **Binary Search** (مرتب، O(log n)) سؤال رایج امتحانی است\n"
    },
    {
      "kind": "ihk_traps",
      "text": "1) **مقدار بازگشتی برای 'پیدا نشده':** `-1` استاندارد است (نه `0`، `null` یا `false`).\n2) **اندیس 0 معتبر است:** اندیس `0` را با 'پیدا نشده' اشتباه نگیر.\n3) **فراموش کردن توقف زودهنگام:** بعد از تطابق **فوراً** `return i` (نه ادامه تا انتها).\n4) **خطای یک‌عددی (Off-by-One):** حلقه از `0` تا `n-1` (نه تا `n`).\n5) **مرتب‌سازی قبلی غیرضروری:** Linear Search روی آرایه‌های **نامرتب** هم کار می‌کند.\n6) **مقایسه با Binary Search:**\n   - Linear Search: O(n), نیازی به مرتب‌سازی ندارد\n   - Binary Search: O(log n), **باید مرتب** باشد\n7) **موارد تکراری:** نسخهٔ کلاسیک فقط **اولین** تطابق را برمی‌گرداند.\n8) **آرایهٔ خالی:** اگر `n = 0`، مقدار `-1` برگردانده می‌شود (بدون تکرار).\n"
    },
    {
      "kind": "variants",
      "text": "**first_hit**\n???: ????? ????? ????? ?? ????????? ?? ??? ??? ???? `-1`.\n???????: Best `O(1)`, Worst `O(n)`, Space `O(1)`.\n??????:\n- ????? 0 ????? ???? ?? ????? ???? ?????? ????.\n- ??? ?? ????? ????? ????.\n\n**all_hits**\n???: ???? ????????? ????? ?? ??? ???.\n???????: Best/Worst `O(n)`, Space `O(k)`.\n??????:\n- ???? ??? ?? ????? ????? ??? ???.\n- ????? ???? ???? ?? ?? ???.\n\n**contains_bool**\n???: ??? `true/false` ????????.\n???????: Best `O(1)`, Worst `O(n)`, Space `O(1)`.\n??????:\n- true/false ?? ?? ????? ?????? ?????.\n- ?? ????? ?????? ????.\n\n**range_limited**\n???: ??????? ??? ?? ????? `[left, right]`.\n???????: `O(right-left+1)`, Space `O(1)`.\n??????:\n- ????? ????? ????? (0 ? left ? right < n).\n- ???? off-by-one.\n\n**start_index**\n???: ??????? ?? `startIndex` ???? ???.\n???????: `O(n-startIndex)`, Space `O(1)`.\n??????:\n- ?????? `startIndex` ?? ?? ??.\n- ???? ?? 0 ???? ???? ???? ??? ??? ???.\n\n**strings_casefold**\n???: ???????? ??????? ???? ?????? ?? ????.\n???????: `O(n*L)`, Space `O(1)`.\n??????:\n- ??? ?? ?? ???? `toLower/casefold` ????? ??.\n- locale/case ?? ?????? ????.\n\n**objects_comparator**\n???: ??????? ???????? ?? ???? `f`.\n???????: `O(n*T_f)`, Space `O(1)`.\n??????:\n- `f(a,b)=0` ???? ?????.\n- ???? comparator ?????? ????.\n\n**predicate**\n???: ????? ????? ?? ??? ?? ??????? ??????.\n???????: Best `O(1)`, Worst `O(n)`, Space `O(1)`.\n??????:\n- ??? ???? ???? ?? ?????.\n- ??? ?? ????? `true` ????.\n\n**generic_comparator**\n???: ?????? ????? ?? `cmp`.\n???????: `O(n*T_cmp)`, Space `O(1)`.\n??????:\n- `cmp(arr[i], x) = 0` ???? ?????.\n- ????? ????????? ?? ?????? ???.\n\n**early_exit_sorted**\n???: ??? ?????? ???? ?? ??? `arr[i] > x` ??? ??? ???.\n???????: Best `O(1)`, Worst `O(n)`, Space `O(1)`.\n??????:\n- ??? ???? ?????? **????** ???? ???.\n- ??? `arr[i] > x` ?? ?? ??????.\n"
    }
  ]
}
