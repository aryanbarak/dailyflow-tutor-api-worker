{
  "schema_name": "tutor_asset.explain.v1",
  "version": "1.0",
  "topic": "maxperiod",
  "lang": "fa",
  "mode": "explain",
  "title": "MaxPeriod (طولانی‌ترین دنباله متوالی) — FIAE Explain Core v1.0",
  "summary": "**MaxPeriod (طولانی‌ترین دنباله متوالی)** الگوریتمی است که **طولانی‌ترین دنباله‌ی پیوسته** از عناصری را پیدا می‌کند که یک **شرط خاص** (مثلاً `a[i] == 1`، `a[i] > 0`، `a[i] != 0`) را برآورده می‌کنند.\n\n**هدف:** پیدا کردن `maxLen` (طول بیشینه)، `startIndex` (شروع دنباله)، و `endIndex` (پایان دنباله) با یک **گذر یکباره** از آرایه.\n\n**نکته کلیدی (امتحانی):** این الگوریتم با **نگه‌داری دو طول** کار می‌کند:\n- `currentLen`: طول دنباله‌ی **جاری** (متغیر موقت که reset می‌شود)\n- `maxLen`: طول **بیشینه‌ی دیده‌شده** تا کنون (فقط وقتی بهتر شد، بروزرسانی می‌شود)",
  "blocks": [
    {
      "kind": "definition",
      "text": "**MaxPeriod (طولانی‌ترین دنباله متوالی)** الگوریتمی است که **طولانی‌ترین دنباله‌ی پیوسته** از عناصری را پیدا می‌کند که یک **شرط خاص** (مثلاً `a[i] == 1`، `a[i] > 0`، `a[i] != 0`) را برآورده می‌کنند.\n\n**هدف:** پیدا کردن `maxLen` (طول بیشینه)، `startIndex` (شروع دنباله)، و `endIndex` (پایان دنباله) با یک **گذر یکباره** از آرایه.\n\n**نکته کلیدی (امتحانی):** این الگوریتم با **نگه‌داری دو طول** کار می‌کند:\n- `currentLen`: طول دنباله‌ی **جاری** (متغیر موقت که reset می‌شود)\n- `maxLen`: طول **بیشینه‌ی دیده‌شده** تا کنون (فقط وقتی بهتر شد، بروزرسانی می‌شود)\n"
    },
    {
      "kind": "idea",
      "text": "تصور کن که آرایه را **عنصر به عنصر** بررسی می‌کنی و یک **شمارنده موقت** (`currentLen`) داری:\n\n**حالت ۱: شرط برقرار است** (مثلاً `a[i] == 1`):\n- شمارنده موقت را یکی افزایش بده: `currentLen += 1`\n- اگر این شمارنده از **رکورد قبلی** (`maxLen`) بیشتر شد → رکورد را بروزرسانی کن\n\n**حالت ۲: شرط برقرار نیست** (مثلاً `a[i] == 0`):\n- دنباله قطع شد → شمارنده موقت را **صفر کن**: `currentLen = 0`\n- رکورد قبلی (`maxLen`) دست نخورده باقی می‌ماند\n\n**تصویر ذهنی:** مثل شمردن روزهای متوالی بدون باران؛ وقتی باران بیاید، شمارنده را از نو شروع می‌کنی ولی **بهترین رکورد قبلی** را فراموش نمی‌کنی.\n"
    },
    {
      "kind": "procedure",
      "text": "MaxPeriod با یک حلقه ساده کار می‌کند:\n\n**۱) مقداردهی اولیه:**\n- `maxLen = 0` (بهترین رکورد دیده‌شده)\n- `currentLen = 0` (شمارنده موقت جاری)\n- `endIndex = -1` (آخرین اندیس دنباله بهترین)\n\n**۲) حلقه اصلی (پیمایش آرایه):**\n- برای هر `i` از `0` تا `n-1`:\n  - **چک شرط:** آیا `a[i]` شرط را برآورده می‌کند؟ (مثلاً `a[i] > 0`)\n  - **اگر بله:**\n    * `currentLen` را یکی افزایش بده\n    * اگر `currentLen > maxLen` → رکورد جدید! بروزرسانی کن: `maxLen = currentLen` و `endIndex = i`\n  - **اگر نه:**\n    * دنباله قطع شد → `currentLen = 0` (reset)\n\n**۳) محاسبه startIndex (بعد از پایان حلقه):**\n- اگر `maxLen > 0` (یعنی حداقل یک دنباله معتبر پیدا شده):\n  * `startIndex = endIndex - maxLen + 1`\n- وگرنه (هیچ دنباله‌ای پیدا نشد):\n  * `startIndex = -1`\n\n**نکته امتحانی:** برخلاف الگوریتم‌های مرتب‌سازی، MaxPeriod **فقط یک حلقه** دارد و **هیچ تو در تویی** ندارد؛ پس پیچیدگی `O(n)` است.\n"
    },
    {
      "kind": "example",
      "text": "????? [0,1,1,0,1,1,1,0] ? ??????????? ??? 3 (????? 4 ?? 6)."
    },
    {
      "kind": "complexity",
      "text": "**زمان:**\n- Best-case: **O(n)** — یک گذر کامل (حتی اگر آرایه همه صفر یا همه یک باشد)\n- Average-case: **O(n)**\n- Worst-case: **O(n)**\n\n**مکان:** **O(1)** — فقط چند متغیر ثابت (`maxLen`, `currentLen`, `endIndex`, `startIndex`)\n\n**مقایسه:**\n- **سریع‌تر از:** الگوریتم‌های مرتب‌سازی (`O(n log n)` یا `O(n²)`)\n- **برابر با:** جستجوی خطی، جمع آرایه (همه `O(n)`)\n- **کندتر از:** دسترسی مستقیم به آرایه (`O(1)`)\n\n**نکته امتحانی:** MaxPeriod یک الگوریتم **خطی بهینه** است؛ نمی‌توان سریع‌تر از `O(n)` این مسئله را حل کرد (چون باید کل آرایه را دید).\n"
    },
    {
      "kind": "ihk_traps",
      "text": "**۱) reset کردن متغیر اشتباه (بحرانی!):**\n- ❌ `maxLen = 0` وقتی شرط نادرست شد\n- ✓ `currentLen = 0` (فقط شمارنده موقت reset می‌شود)\n- **علت:** `maxLen` رکورد کلی است، نباید دست خورد\n\n**۲) فراموش کردن reset برای شرط نادرست:**\n- ❌ وقتی `a[i]` شرط را ندارد، `currentLen` reset نشود\n- ✓ در بلوک `else`: `currentLen = 0`\n- **نتیجه:** دنباله‌های قطع‌شده به اشتباه ادامه پیدا می‌کنند\n\n**۳) خطای یک واحدی (off-by-one) در فرمول startIndex:**\n- ❌ `startIndex = endIndex - maxLen` (یکی کم)\n- ❌ `startIndex = endIndex - maxLen + 2` (یکی زیاد)\n- ✓ `startIndex = endIndex - maxLen + 1`\n- **مثال:** اگر `endIndex=6` و `maxLen=3` → `startIndex = 6-3+1 = 4` (صحیح)\n\n**۴) استفاده از >= به‌جای > در بروزرسانی (رفتار تساوی):**\n- با `>`: اولین (earliest) دنباله با بیشترین طول حفظ می‌شود\n- با `>=`: آخرین (latest) دنباله با بیشترین طول حفظ می‌شود\n- **IHK:** معمولاً `>` خواسته می‌شود (earliest tie)\n\n**۵) فراموش کردن چک maxLen > 0 قبل از محاسبه startIndex:**\n- اگر هیچ دنباله معتبری نبود (مثلاً همه صفر):\n  * `maxLen = 0`, `endIndex = -1`\n  * اگر `startIndex = endIndex - maxLen + 1` محاسبه کنیم → `startIndex = -1 - 0 + 1 = 0` (اشتباه!)\n- ✓ چک کن: اگر `maxLen == 0` → `startIndex = -1`\n\n**۶) عدم مدیریت آرایه خالی:**\n- اگر `n == 0` → باید `maxLen=0`, `startIndex=-1`, `endIndex=-1`\n- ✓ کد باید حالت خالی را مدیریت کند (حلقه اصلاً اجرا نمی‌شود)\n\n**۷) اشتباه در شرط (مثلاً > به‌جای !=):**\n- اگر سوال می‌گوید \"غیرصفر\" → شرط `a[i] != 0` (نه `> 0`)\n- اگر سوال می‌گوید \"مثبت\" → شرط `a[i] > 0`\n- ✓ دقت به متن سوال امتحانی\n\n**۸) فراموش کردن آخرین عنصر:**\n- ❌ حلقه تا `i < n-1` (عنصر آخر بررسی نمی‌شود)\n- ✓ حلقه تا `i < n` یا `i <= n-1`\n\n**۹) خروجی نادرست برای \"بدون دنباله\":**\n- اگر هیچ دنباله‌ای نبود:\n  * ✓ `maxLen = 0`, `startIndex = -1`, `endIndex = -1`\n  * ❌ `startIndex = 0` (اشتباه، چون دنباله‌ای وجود ندارد)\n\n**۱۰) پیچیدگی اشتباه:**\n- ❌ گفتن `O(n²)` (فکر کردن الگوریتم مثل مرتب‌سازی است)\n- ✓ `O(n)` (فقط یک حلقه ساده)\n"
    },
    {
      "kind": "variants",
      "text": "MaxPeriod سه نسخه اصلی دارد:\n\n**۱) longest_ones_binary (کلاسیک، آرایه دودویی):**\n- شرط: `a[i] == 1`\n- کاربرد: دنباله روزهای فعال (0=غیرفعال، 1=فعال)\n- مثال: `[0,1,1,0,1,1,1] → maxLen=3`\n\n**۲) longest_nonzero_run (تعمیم‌یافته):**\n- شرط: `a[i] != 0`\n- با اعداد منفی کار می‌کند\n- کاربرد: دنباله روزهای با تراکنش (0=بدون تراکنش، غیرصفر=دارای تراکنش)\n- مثال: `[0, -5, 3, 0, 2, -1, 4] → maxLen=3` (اندیس‌های 4-6)\n\n**۳) longest_condition_run (Predicate، شرط دلخواه):**\n- شرط: یک تابع کلی (مثل `a[i] > threshold`)\n- انعطاف‌پذیرترین نسخه\n- کاربرد: دنباله روزهای بالاتر از حد معین، دنباله اعداد زوج، دنباله مقادیر معتبر\n- مثال: `a=[5, 10, 3, 12, 15, 2], threshold=8 → maxLen=2` (اندیس‌های 3-4: `[12,15]`)\n\n**مقایسه:**\n\n| Variant | شرط | کار با منفی | انعطاف | کاربرد IHK |\n|---------|------|-------------|--------|------------|\n| binary | `== 1` | ❌ | کم | ساده‌ترین |\n| nonzero | `!= 0` | ✓ | متوسط | معمول |\n| condition | دلخواه | بستگی دارد | زیاد | پیشرفته |\n\n**نکته امتحانی:** نسخه `condition` **قالب کلی** است؛ با تنظیم شرط می‌توان نسخه‌های دیگر را ساخت.\n"
    }
  ]
}
