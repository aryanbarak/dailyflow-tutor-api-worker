{
  "schema_name": "tutor_asset.explain.v1",
  "version": "1.0",
  "topic": "minimum",
  "lang": "fa",
  "mode": "explain",
  "title": "Minimum (کمینه‌یابی) — FIAE Core (فارسی)",
  "summary": "**Minimum (کمینه‌یابی)** یک الگوریتم پایه است که **کوچکترین عنصر** را در یک آرایه یا بخشی از آن پیدا می‌کند و **اندیس** آن را برمی‌گرداند.\n\n**هدف:** پیدا کردن کمینه (کوچکترین مقدار) در یک محدوده مشخص از آرایه با **جستجوی خطی** (Sequential Scan).\n\n**پارامترها:**\n- `arr`: آرایه‌ای که باید جستجو شود (هر نوعی که عملگر مقایسه داشته باشد)\n- `start_index`: موقعیت شروع جستجو (پیش‌فرض: 0)\n- اختیاری: `end_index` برای جستجو در محدوده\n\n**مقدار برگشتی:** **اندیس** کوچکترین عنصر در محدوده `[start_index .. انتها]` (نه خود مقدار!)\n\n**نکته کلیدی (امتحانی):** این الگوریتم **خطی** است — یعنی عناصر را **یکی یکی** از موقعیت شروع تا انتها بررسی می‌کند. امکان **خروج زودهنگام** وجود ندارد (مثل جستجوی دودویی). پیچیدگی: **همیشه O(n)**.\n\n**رایج‌ترین استفاده:** به عنوان تابع کمکی در **SelectionSort** (در هر دور، کمینه را در بخش باقی‌مانده پیدا می‌کند).",
  "blocks": [
    {
      "kind": "definition",
      "text": "**Minimum (کمینه‌یابی)** یک الگوریتم پایه است که **کوچکترین عنصر** را در یک آرایه یا بخشی از آن پیدا می‌کند و **اندیس** آن را برمی‌گرداند.\n\n**هدف:** پیدا کردن کمینه (کوچکترین مقدار) در یک محدوده مشخص از آرایه با **جستجوی خطی** (Sequential Scan).\n\n**پارامترها:**\n- `arr`: آرایه‌ای که باید جستجو شود (هر نوعی که عملگر مقایسه داشته باشد)\n- `start_index`: موقعیت شروع جستجو (پیش‌فرض: 0)\n- اختیاری: `end_index` برای جستجو در محدوده\n\n**مقدار برگشتی:** **اندیس** کوچکترین عنصر در محدوده `[start_index .. انتها]` (نه خود مقدار!)\n\n**نکته کلیدی (امتحانی):** این الگوریتم **خطی** است — یعنی عناصر را **یکی یکی** از موقعیت شروع تا انتها بررسی می‌کند. امکان **خروج زودهنگام** وجود ندارد (مثل جستجوی دودویی). پیچیدگی: **همیشه O(n)**.\n\n**رایج‌ترین استفاده:** به عنوان تابع کمکی در **SelectionSort** (در هر دور، کمینه را در بخش باقی‌مانده پیدا می‌کند).\n"
    },
    {
      "kind": "idea",
      "text": "تصور کن که یک **ردیف از اعداد** روی کاغذ داری و دنبال **کوچکترین** می‌گردی:\n\n**روش:**\n1. اولین عدد را به عنوان \"کمینه فعلی\" **به یاد می‌سپاری** (همراه با موقعیتش).\n2. از تمام اعداد بعدی **یکی یکی** می‌گذری.\n3. اگر عدد **کوچکتری** پیدا کردی → کمینه ذخیره شده را به‌روز می‌کنی.\n4. در پایان، مطمئناً کوچکترین عنصر را پیدا کرده‌ای.\n\n**قیاس:** مثل ورق زدن یک لیست قیمت برای پیدا کردن ارزان‌ترین مورد — باید به هر ورودی نگاه کنی، میانبر وجود ندارد.\n\n**مثال:** `[64, 25, 12, 22, 11]` از اندیس 0\n- شروع: min = 64 (اندیس 0) — اولین عدد \"کاندید\" است\n- دیدن 25 → 25 < 64 → min = 25 (اندیس 1) — کاندید جدید\n- دیدن 12 → 12 < 25 → min = 12 (اندیس 2) — حتی بهتر\n- دیدن 22 → 22 کوچکتر از 12 نیست → min همچنان 12\n- دیدن 11 → 11 < 12 → min = 11 (اندیس 4) — برنده نهایی\n- **نتیجه:** اندیس 4 (مقدار: 11)\n\n**جمله کلیدی:** \"یکی یکی — امکان رد شدن وجود ندارد.\"\n"
    },
    {
      "kind": "procedure",
      "text": "الگوریتم Minimum با یک حلقه ساده کار می‌کند:\n\n**1) مقداردهی اولیه:**\n- `minIndex = start_index` را تنظیم کن\n- `min = arr[start_index]` را تنظیم کن (مقدار در آن موقعیت)\n- عنصر در موقعیت `start_index` اولین \"کاندید\" برای کمینه است\n- **مهم:** هرگز `min = 0` یا `min = ∞` تنظیم نکن — همیشه از اولین عنصر واقعی آرایه استفاده کن!\n\n**2) حلقه اصلی (مقایسه‌ها):**\n- از تمام موقعیت‌های `j` از `start_index + 1` تا `انتهای آرایه` بگذر\n- برای هر `j`:\n  * `arr[j]` را با مقدار فعلی `arr[minIndex]` (یا `min`) مقایسه کن\n  * اگر `arr[j] < min` → هر دو را به‌روز کن: `minIndex = j` و `min = arr[j]`\n  * در غیر این صورت → این عنصر را نادیده بگیر و ادامه بده\n- **امکان توقف زودهنگام وجود ندارد** — حلقه همیشه تا انتها اجرا می‌شود!\n\n**3) برگرداندن:**\n- `minIndex` را برگردان (اندیس کوچکترین عنصر)\n- **نه** خود مقدار — فراخواننده می‌تواند با `arr[minIndex]` به آن دسترسی پیدا کند\n\n**نکته امتحانی:** الگوریتم **همیشه (n - start_index - 1) مقایسه** انجام می‌دهد، صرف‌نظر از مرتب‌سازی آرایه (امکان خروج زودهنگام وجود ندارد). Best-Case = Worst-Case = Average-Case.\n"
    },
    {
      "kind": "example",
      "text": "????? [64,25,12,22,11] ? ????? ?? ????? 4 (????? 11)."
    },
    {
      "kind": "complexity",
      "text": "**زمان (Time):**\n- تعداد مقایسه‌ها **همیشه یکسان** است:\n  - دقیقاً: **(n - start_index - 1)** مقایسه\n  - برای `n = 10`, `start_index = 0` → **9 مقایسه**\n  - برای `n = 100`, `start_index = 20` → **79 مقایسه**\n- **Best-Case: O(n)** — حتی اگر از قبل مرتب باشد\n- **Average-Case: O(n)** — حالت معمولی\n- **Worst-Case: O(n)** — حالت بدتری وجود ندارد\n- **مهم:** امکان **خروج زودهنگام** وجود ندارد (برخلاف جستجوی خطی با پرچم `found`)\n\n**چرا همیشه O(n)؟**\nبرای اطمینان از اینکه کمینه را داریم، باید به **هر عنصر نگاه کنیم** — ممکن است کوچکترین عنصر در انتها باشد.\n\n**حافظه (Space):**\n- **O(1)** — فقط حافظه ثابت اضافی\n- متغیرها: `minIndex`, `min`, `j` (متغیر حلقه)\n- نیاز به آرایه اضافی نیست\n- الگوریتم **In-Place** است\n\n**تعداد به‌روزرسانی‌ها (Best vs. Worst):**\n- **Best-Case:** 0 به‌روزرسانی (آرایه از قبل صعودی مرتب شده)\n- **Worst-Case:** (n-1) به‌روزرسانی (آرایه نزولی مرتب شده)\n- **Average-Case:** ~(ln n) به‌روزرسانی (قابل اثبات ریاضی)\n- **ولی:** به‌روزرسانی‌ها تغییری در پیچیدگی O(n) نمی‌دهند!\n\n**مقایسه با جستجوی دودویی:**\n- جستجوی دودویی: **O(log n)** — اما فقط در آرایه‌های **مرتب**\n- Minimum: **O(n)** — در آرایه‌های **نامرتب** هم کار می‌کند\n- در آرایه نامرتب: Minimum **بهینه** است (قابل بهبود نیست)\n"
    },
    {
      "kind": "ihk_traps",
      "text": "**1) مقداردهی اولیه با ثابت به جای اولین عنصر**\n- ❌ غلط: `min = 0` یا `min = ∞` یا `min = Integer.MAX_VALUE`\n- ✓ درست: `min = arr[start_index]`\n- **دلیل:** آرایه ممکن است فقط اعداد منفی داشته باشد (مثلاً `[-5, -2, -8]`)\n\n**2) فراموش کردن start_index**\n- ❌ غلط: حلقه از 0 شروع می‌شود، در حالی که `start_index = 5`\n- ✓ درست: حلقه از `start_index + 1` شروع می‌شود\n- **سؤال امتحانی:** \"چند مقایسه با n=100, start=20؟\" → جواب: 79 (نه 99!)\n\n**3) اندیس در برابر مقدار (رایج‌ترین خطا!)**\n- ❌ غلط: تابع `min` (مقدار) را برمی‌گرداند\n- ✓ درست: تابع `minIndex` (موقعیت) را برمی‌گرداند\n- **چرا اندیس؟** چون SelectionSort به موقعیت نیاز دارد تا swap کند!\n\n**4) حلقه از start_index شروع می‌شود به جای start_index + 1**\n- ❌ غلط: `for j = start_index to n-1`\n- ✓ درست: `for j = start_index + 1 to n-1`\n- **دلیل:** موقعیت اول از قبل مقداردهی شده → مقایسه غیرضروری\n\n**5) اشتباه گرفتن با جستجوی دودویی**\n- ❌ غلط: \"کمینه می‌تواند با O(log n) پیدا شود\"\n- ✓ درست: کمینه **همیشه O(n)** در آرایه‌های نامرتب نیاز دارد\n- **دلیل:** جستجوی دودویی فقط در آرایه‌های **مرتب** کار می‌کند\n\n**6) آرایه خالی / Out-of-Bounds**\n- ❌ غلط: بدون مدیریت خطا برای آرایه خالی\n- ✓ درست: `if (arr.length == 0) return -1;` یا پرتاب Exception\n- **امتحان:** مدیریت Edge-Case اغلب پرسیده می‌شود!\n\n**7) چند کمینه (پایداری)**\n- اگر چند عنصر به اندازه هم کوچک باشند → **اولین** پیدا می‌شود\n- مثال: `[5, 2, 8, 2]` → اندیس **1** (نه 3)\n- **دلیل:** شرط `<` است (نه `<=`)\n\n**8) تخمین اشتباه Best-Case**\n- ❌ غلط: \"Best-Case O(1) اگر اولین عنصر کمینه باشد\"\n- ✓ درست: Best-Case همچنان **O(n)** — همه مقایسه‌ها لازم است\n- **تفاوت با Contains:** Contains می‌تواند در صورت یافتن متوقف شود!\n"
    },
    {
      "kind": "variants",
      "text": "در این پیاده‌سازی، **فقط یک Variant استاندارد** برای Minimum وجود دارد:\n\n**Variant پیاده‌سازی شده:**\n\n**1) استاندارد - کمینه از Startindex (`int_asc`)**\n- **عنوان فارسی:** کمینه استاندارد (عدد صحیح)\n- **توضیح:** کوچکترین عنصر را در یک آرایه عدد صحیح پیدا می‌کند\n- **پارامترها:**\n  - `arr`: آرایه اعداد صحیح (Integer array)\n  - `start`: اندیس شروع جستجو (پیش‌فرض: 0)\n- **مقدار برگشتی:** `minIndex` — اندیس (موقعیت) کوچکترین عنصر\n- **محدوده جستجو:** از `start` تا انتهای آرایه (`n-1`)\n- **کاربرد اصلی:** به عنوان تابع کمکی در **SelectionSort** — در هر دور، کمینه را از موقعیت `i` به بعد پیدا می‌کند\n- **ویژگی‌ها:**\n  - الگوریتم خطی: **O(n)** در همه حالات\n  - تعداد مقایسه‌ها: **(n - start - 1)**\n  - In-Place: حافظه اضافی **O(1)**\n  - مقایسه مستقیم: از عملگر `<` برای اعداد صحیح استفاده می‌کند\n\n**دام‌های رایج این Variant:**\n- ❌ **اشتباه 1:** مقداردهی اولیه با `min = 0` به جای `min = arr[start]`\n  - **مشکل:** اگر آرایه فقط اعداد منفی داشته باشد (مثلاً `[-5, -2, -8]`)، نتیجه غلط می‌شود\n- ❌ **اشتباه 2:** حلقه از `start` شروع می‌شود به جای `start + 1`\n  - **مشکل:** مقایسه غیرضروری عنصر اول با خودش\n- ❌ **اشتباه 3:** برگرداندن `min` (مقدار) به جای `minIndex` (اندیس)\n  - **مشکل:** SelectionSort به اندیس نیاز دارد تا عناصر را جابجا کند!\n- ❌ **اشتباه 4:** فراموش کردن مدیریت آرایه خالی\n  - **مشکل:** دسترسی به `arr[0]` با آرایه خالی → خطای Out-of-Bounds\n\n**سؤال امتحانی متداول:**\n- \"چند مقایسه برای آرایه 100 عنصری با `start = 20`؟\"\n  - **جواب:** 79 مقایسه (فرمول: n - start - 1 = 100 - 20 - 1)\n\n**نکته مهم (IHK):**\nاین Variant **استاندارد** است و همان چیزی است که در امتحانات IHK از شما خواسته می‌شود. تمرکز اصلی:\n- درک صحیح مقداردهی اولیه\n- تمایز بین اندیس و مقدار\n- محاسبه دقیق تعداد مقایسه‌ها\n- مدیریت حالات مرزی (Edge Cases)\n\n**مقایسه با SelectionSort:**\nSelectionSort در هر دور `i` این تابع را با `start = i` صدا می‌زند:\n- دور 0: `Minimum(arr, 0)` → کمینه در کل آرایه\n- دور 1: `Minimum(arr, 1)` → کمینه در بخش باقی‌مانده\n- دور 2: `Minimum(arr, 2)` → و الی آخر\n- عناصر قبل از `i` از قبل مرتب شده‌اند و نادیده گرفته می‌شوند\n"
    }
  ]
}
