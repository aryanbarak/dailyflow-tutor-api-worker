{
  "schema_name": "tutor_asset.explain.v1",
  "version": "1.0",
  "topic": "minimum",
  "lang": "de",
  "mode": "explain",
  "title": "Minimum (Minimumsuche) — FIAE Explain Core v1.0",
  "summary": "**Minimum (Minimumsuche)** ist ein grundlegender Algorithmus, der das **kleinste Element** in einem Array oder Teilbereich findet und dessen **Index** zurückgibt.\n\n**Ziel:** Das Minimum (kleinster Wert) in einem gegebenen Bereich eines Arrays finden durch **lineares Durchsuchen** (Sequential Scan).\n\n**Parameter:**\n- `arr`: Das zu durchsuchende Array (beliebiger Typ mit Vergleichsoperator)\n- `start_index`: Startposition der Suche (Standard: 0)\n- Optional: `end_index` für Bereichssuche\n\n**Rückgabewert:** **Index** des kleinsten Elements im Bereich `[start_index .. Ende]` (nicht der Wert selbst!)\n\n**Wichtiger Hinweis (Prüfung):** Dieser Algorithmus ist **linear** — d.h. er prüft Elemente **nacheinander** von der Startposition bis zum Ende. Es gibt **kein Early-Exit** wie bei der binären Suche. Komplexität: **immer O(n)**.\n\n**Häufigster Einsatz:** Als Hilfsfunktion in **SelectionSort** (findet in jedem Durchlauf das Minimum im Restbereich).",
  "blocks": [
    {
      "kind": "definition",
      "text": "**Minimum (Minimumsuche)** ist ein grundlegender Algorithmus, der das **kleinste Element** in einem Array oder Teilbereich findet und dessen **Index** zurückgibt.\n\n**Ziel:** Das Minimum (kleinster Wert) in einem gegebenen Bereich eines Arrays finden durch **lineares Durchsuchen** (Sequential Scan).\n\n**Parameter:**\n- `arr`: Das zu durchsuchende Array (beliebiger Typ mit Vergleichsoperator)\n- `start_index`: Startposition der Suche (Standard: 0)\n- Optional: `end_index` für Bereichssuche\n\n**Rückgabewert:** **Index** des kleinsten Elements im Bereich `[start_index .. Ende]` (nicht der Wert selbst!)\n\n**Wichtiger Hinweis (Prüfung):** Dieser Algorithmus ist **linear** — d.h. er prüft Elemente **nacheinander** von der Startposition bis zum Ende. Es gibt **kein Early-Exit** wie bei der binären Suche. Komplexität: **immer O(n)**.\n\n**Häufigster Einsatz:** Als Hilfsfunktion in **SelectionSort** (findet in jedem Durchlauf das Minimum im Restbereich).\n"
    },
    {
      "kind": "idea",
      "text": "Stell dir vor, du hast eine **Reihe von Zahlen** auf Papier und suchst die **kleinste**:\n\n**Methode:**\n1. Du **merkst dir** die erste Zahl als \"aktuelles Minimum\" (samt Position).\n2. Du gehst durch alle folgenden Zahlen **eine nach der anderen**.\n3. Wenn du eine **kleinere** Zahl findest → aktualisierst du dein gemerktes Minimum.\n4. Am Ende hast du garantiert das kleinste Element gefunden.\n\n**Analogie:** Wie das Durchblättern einer Preisliste, um den günstigsten Artikel zu finden — du musst jeden Eintrag ansehen, es gibt keine Abkürzung.\n\n**Beispiel:** `[64, 25, 12, 22, 11]` ab Index 0\n- Start: min = 64 (Index 0) — erste Zahl ist \"Kandidat\"\n- Sehe 25 → 25 < 64 → min = 25 (Index 1) — neuer Kandidat\n- Sehe 12 → 12 < 25 → min = 12 (Index 2) — noch besser\n- Sehe 22 → 22 nicht kleiner als 12 → min bleibt 12\n- Sehe 11 → 11 < 12 → min = 11 (Index 4) — finaler Gewinner\n- **Ergebnis:** Index 4 (Wert: 11)\n\n**Merksatz:** \"Eine Zahl nach der anderen — kein Überspringen möglich.\"\n"
    },
    {
      "kind": "procedure",
      "text": "Der Minimum-Algorithmus arbeitet mit einer einfachen Schleife:\n\n**1) Initialisierung:**\n- Setze `minIndex = start_index`\n- Setze `min = arr[start_index]` (der Wert an dieser Position)\n- Das Element an Position `start_index` ist der erste \"Kandidat\" für das Minimum\n- **Wichtig:** Niemals `min = 0` oder `min = ∞` setzen — verwende immer das erste tatsächliche Array-Element!\n\n**2) Hauptschleife (Vergleiche):**\n- Laufe durch alle Positionen `j` von `start_index + 1` bis `Ende des Arrays`\n- Für jedes `j`:\n  * Vergleiche `arr[j]` mit dem aktuellen Wert `arr[minIndex]` (oder `min`)\n  * Wenn `arr[j] < min` → aktualisiere beide: `minIndex = j` und `min = arr[j]`\n  * Sonst → ignoriere dieses Element und mach weiter\n- **Keine vorzeitige Abbruchmöglichkeit** — die Schleife läuft immer bis zum Ende!\n\n**3) Rückgabe:**\n- Gib `minIndex` zurück (Index des kleinsten Elements)\n- **Nicht** den Wert selbst — der Aufrufer kann mit `arr[minIndex]` darauf zugreifen\n\n**Prüfungstipp:** Der Algorithmus macht **immer (n - start_index - 1) Vergleiche**, unabhängig von der Sortierung des Arrays (keine Early-Exit-Möglichkeit). Best-Case = Worst-Case = Average-Case.\n"
    },
    {
      "kind": "example",
      "text": "Array [64,25,12,22,11] ? Minimum bei Index 4 (Wert 11)."
    },
    {
      "kind": "complexity",
      "text": "**Zeit (Time):**\n- Anzahl der Vergleiche ist **immer gleich**:\n  - Exakt: **(n - start_index - 1)** Vergleiche\n  - Für `n = 10`, `start_index = 0` → **9 Vergleiche**\n  - Für `n = 100`, `start_index = 20` → **79 Vergleiche**\n- **Best-Case: O(n)** — selbst wenn bereits sortiert\n- **Average-Case: O(n)** — typischer Fall\n- **Worst-Case: O(n)** — kein schlechterer Fall möglich\n- **Wichtig:** Es gibt **kein Early-Exit** (im Gegensatz zu linearer Suche mit `found`-Flag)\n\n**Warum immer O(n)?**\nUm sicher zu sein, dass wir das Minimum haben, müssen wir **jedes Element anschauen** — es könnte sein, dass das kleinste Element ganz am Ende steht.\n\n**Speicher (Space):**\n- **O(1)** — nur konstanter Zusatzspeicher\n- Variablen: `minIndex`, `min`, `j` (Schleifenvariable)\n- Kein zusätzliches Array nötig\n- Algorithmus ist **In-Place**\n\n**Anzahl Updates (Best vs. Worst):**\n- **Best-Case:** 0 Updates (Array bereits aufsteigend sortiert)\n- **Worst-Case:** (n-1) Updates (Array absteigend sortiert)\n- **Average-Case:** ~(ln n) Updates (mathematisch beweisbar)\n- **Aber:** Updates ändern nichts an der O(n)-Komplexität!\n\n**Vergleich mit binärer Suche:**\n- Binäre Suche: **O(log n)** — aber nur in **sortierten** Arrays\n- Minimum: **O(n)** — funktioniert auch in **unsortierten** Arrays\n- In unsortiertem Array: Minimum ist **optimal** (nicht verbesserbar)\n"
    },
    {
      "kind": "ihk_traps",
      "text": "**1) Initialisierung mit Konstante statt erstem Element**\n- ❌ FALSCH: `min = 0` oder `min = ∞` oder `min = Integer.MAX_VALUE`\n- ✓ RICHTIG: `min = arr[start_index]`\n- **Grund:** Array könnte nur negative Zahlen enthalten (z.B. `[-5, -2, -8]`)\n\n**2) Start-Index vergessen**\n- ❌ FALSCH: Schleife beginnt bei 0, obwohl `start_index = 5`\n- ✓ RICHTIG: Schleife beginnt bei `start_index + 1`\n- **Prüfungsfrage:** \"Wie viele Vergleiche bei n=100, start=20?\" → Antwort: 79 (nicht 99!)\n\n**3) Index vs. Wert (häufigster Fehler!)**\n- ❌ FALSCH: Funktion gibt `min` (den Wert) zurück\n- ✓ RICHTIG: Funktion gibt `minIndex` (die Position) zurück\n- **Warum Index?** Weil SelectionSort die Position braucht, um zu tauschen!\n\n**4) Schleife beginnt bei start_index statt start_index + 1**\n- ❌ FALSCH: `for j = start_index bis n-1`\n- ✓ RICHTIG: `for j = start_index + 1 bis n-1`\n- **Grund:** Erste Position ist schon initialisiert → unnötiger Vergleich\n\n**5) Verwechslung mit binärer Suche**\n- ❌ FALSCH: \"Minimum kann mit O(log n) gefunden werden\"\n- ✓ RICHTIG: Minimum benötigt **immer O(n)** in unsortierten Arrays\n- **Grund:** Binäre Suche funktioniert nur in **sortierten** Arrays\n\n**6) Leeres Array / Out-of-Bounds**\n- ❌ FALSCH: Keine Fehlerbehandlung für leeres Array\n- ✓ RICHTIG: `if (arr.length == 0) return -1;` oder Exception werfen\n- **Prüfung:** Edge-Case-Handling wird gerne gefragt!\n\n**7) Mehrfache Minima (Stabilität)**\n- Wenn mehrere Elemente gleich klein sind → wird das **erste** gefunden\n- Beispiel: `[5, 2, 8, 2]` → Index **1** (nicht 3)\n- **Grund:** Bedingung ist `<` (nicht `<=`)\n\n**8) Best-Case falsch eingeschätzt**\n- ❌ FALSCH: \"Best-Case O(1) wenn erstes Element das Minimum ist\"\n- ✓ RICHTIG: Best-Case bleibt **O(n)** — alle Vergleiche nötig\n- **Unterschied zu Contains:** Contains kann abbrechen bei Treffer!\n"
    },
    {
      "kind": "variants",
      "text": "**int_asc**\nZiel: Kleinstes Element in einem Integer-Array finden und Index zur?ckgeben.\nPseudocode: `FindMin(arr)` (linearer Scan).\nKomplexit?t: Best/Worst `O(n)`, Space `O(1)`.\nTraps:\n- R?ckgabe ist **Index**, nicht Wert.\n- Start mit `arr[0]`, kein `min = 0`.\n"
    }
  ]
}
