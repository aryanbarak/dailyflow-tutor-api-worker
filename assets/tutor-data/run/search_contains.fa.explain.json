{
  "schema_name": "tutor_asset.explain.v1",
  "version": "1.0",
  "topic": "search_contains",
  "lang": "fa",
  "mode": "explain",
  "title": "Search/Contains — FIAE Core (فارسی)",
  "summary": "**Search/Contains (جستجو/شامل بودن)** خانواده‌ای از الگوریتم‌هاست که **جستجوی خطی** (linear search) را در آرایه‌ها یا رشته‌ها انجام می‌دهند. این الگوریتم‌ها از ابتدا تا انتها یک مجموعه را بررسی می‌کنند تا:\n- **بررسی وجود:** آیا یک عنصر/زیررشته وجود دارد؟ (`contains`)\n- **پیدا کردن موقعیت:** اولین اندیس تطابق کجاست؟ (`indexOf`)\n- **شمارش:** چند بار یک عنصر/زیررشته ظاهر می‌شود؟ (`count`)\n\n**هدف:** پیدا کردن یا شمارش یک الگو (pattern) در یک مجموعه داده با **یک یا چند گذر کامل**.\n\n**نکته کلیدی (امتحانی):** همه این الگوریتم‌ها **جستجوی خطی** هستند — یعنی عناصر را **یکی یکی** از ابتدا تا انتها بررسی می‌کنند (برخلاف binary search که مرتب‌سازی نیاز دارد).",
  "blocks": [
    {
      "kind": "definition",
      "text": "**Search/Contains (جستجو/شامل بودن)** خانواده‌ای از الگوریتم‌هاست که **جستجوی خطی** (linear search) را در آرایه‌ها یا رشته‌ها انجام می‌دهند. این الگوریتم‌ها از ابتدا تا انتها یک مجموعه را بررسی می‌کنند تا:\n- **بررسی وجود:** آیا یک عنصر/زیررشته وجود دارد؟ (`contains`)\n- **پیدا کردن موقعیت:** اولین اندیس تطابق کجاست؟ (`indexOf`)\n- **شمارش:** چند بار یک عنصر/زیررشته ظاهر می‌شود؟ (`count`)\n\n**هدف:** پیدا کردن یا شمارش یک الگو (pattern) در یک مجموعه داده با **یک یا چند گذر کامل**.\n\n**نکته کلیدی (امتحانی):** همه این الگوریتم‌ها **جستجوی خطی** هستند — یعنی عناصر را **یکی یکی** از ابتدا تا انتها بررسی می‌کنند (برخلاف binary search که مرتب‌سازی نیاز دارد)."
    },
    {
      "kind": "idea",
      "text": "تصور کن که یک **کتاب** داری و دنبال یک **کلمه** می‌گردی:\n\n**روش ۱: بررسی وجود (contains):**\n- صفحات را یکی یکی ورق می‌زنی\n- اولین باری که کلمه را دیدی → متوقف می‌شوی و می‌گویی \"پیدا شد!\"\n- اگر کتاب تمام شد و چیزی پیدا نکردی → می‌گویی \"وجود ندارد\"\n\n**روش ۲: پیدا کردن موقعیت (indexOf):**\n- همان کار روش ۱، ولی وقتی پیدا کردی، **شماره صفحه** را یادداشت می‌کنی\n- اگر پیدا نکردی → می‌گویی \"-1\" (قرارداد برای \"پیدا نشد\")\n\n**روش ۳: شمارش (count):**\n- باید **کل کتاب** را بخوانی (نه فقط تا اولین تطابق)\n- هر بار که کلمه را دیدی، یک عدد اضافه می‌کنی\n- در پایان → تعداد کل را گزارش می‌کنی\n\n**تصویر ذهنی:** مثل جستجوی یک نام در یک لیست بلند — اگر فقط می‌خواهی بدانی \"هست یا نیست\"، می‌توانی وقتی پیدا کردی متوقف شوی. اگر می‌خواهی \"چند بار\" هست، باید کل لیست را بخوانی."
    },
    {
      "kind": "procedure",
      "text": "Search/Contains با یک یا دو حلقه کار می‌کند:\n\n**۱) جستجوی ساده (contains_char, count_char):**\n- **یک حلقه:** روی همه عناصر `i = 0 BIS LAENGE(text)-1`\n- **مقایسه:** آیا `text[i] == target`؟\n- **contains:** اولین تطابق → `return true`، انتهای حلقه → `return false`\n- **count:** هر تطابق → `count++`, انتهای حلقه → `return count`\n\n**۲) جستجوی زیررشته (contains_substring, indexOf, count_substring):**\n- **حلقه بیرونی:** روی موقعیت‌های شروع ممکن `i = 0 BIS n-m`\n  * `n = LAENGE(text)`, `m = LAENGE(pattern)`\n  * نکته: `n-m` (نه `n-1`) چون باید جا برای pattern باشد\n- **حلقه داخلی:** مقایسه کاراکتر به کاراکتر `j = 0 BIS m-1`\n  * آیا `text[i+j] == pattern[j]`؟\n  * اولین عدم تطابق → `break` و امتحان موقعیت بعدی\n- **اگر همه تطابق داشتند:**\n  * **contains:** → `return true`\n  * **indexOf:** → `return i`\n  * **count:** → `count++` و **پرش** به `i+m` (برای غیر همپوشان)\n\n**۳) بهینه‌سازی‌های خاص (startsWith, endsWith):**\n- **startsWith:** فقط اندیس 0 چک می‌شود (یک موقعیت)\n- **endsWith:** فقط اندیس `n-m` چک می‌شود (یک موقعیت)\n- هیچ جستجویی در کل text نیست → سریع‌تر `O(m)`\n\n**نکته امتحانی:** تفاوت اصلی بین نسخه‌ها در **توقف زودهنگام** (early return) یا **ادامه حلقه** است:\n- **contains/indexOf:** می‌توانند زود برگردند\n- **count:** باید کل مجموعه را ببینند"
    },
    {
      "kind": "example",
      "text": "text=\"hello\" شامل \"ll\" است؟ نتیجه: true و indexOf=2."
    },
    {
      "kind": "complexity",
      "text": "**پیچیدگی بر اساس نسخه:**\n\n**۱) جستجوی ساده (contains_char, count_char):**\n- Best-case: **O(1)** — اولین عنصر تطابق دارد (فقط برای contains)\n- Average-case: **O(n)**\n- Worst-case: **O(n)** — کل text باید بررسی شود\n- `n = LAENGE(text)`\n\n**۲) جستجوی زیررشته (contains_substring, indexOf, count_substring):**\n- Best-case: **O(m)** — اولین موقعیت تطابق کامل دارد\n- Average-case: **O(n * m)** — بیشتر موقعیت‌ها را باید چک کرد\n- Worst-case: **O(n * m)** — مثال: `text=\"aaaa\"`, `pattern=\"aaab\"` → هر موقعیت تا آخر چک می‌شود\n- `n = LAENGE(text)`, `m = LAENGE(pattern)`\n\n**۳) startsWith / endsWith:**\n- همیشه: **O(m)** — فقط یک موقعیت چک می‌شود\n\n**مکان:** **O(1)** — فقط چند متغیر ثابت (i, j, count, gefunden)\n\n**نکته امتحانی:** naive برای IHK کافی است؛ KMP/Boyer-Moore معمولاً لازم نیست."
    },
    {
      "kind": "ihk_traps",
      "text": "**۱) محدوده حلقه اشتباه برای substring (بحرانی):**\n- ❌ `i = 0 BIS n-1`\n- ✓ `i = 0 BIS n-m`\n\n**۲) اندیس اشتباه در حلقه داخلی:**\n- ❌ `text[j]` یا `text[i]`\n- ✓ `text[i+j]`\n\n**۳) همپوشان vs غیرهمپوشان در count_substring (تله رایج):**\n- غیرهمپوشان: بعد از match → `i = i + m`\n- همپوشان: بعد از match → `i++`\n\n**۴) فراموش کردن early return در contains/indexOf:**\n- ✓ وقتی match شد فوراً return کن\n\n**۵) break جای غلط:**\n- ✓ break در حلقه داخلی وقتی mismatch شد\n- ❌ break در حلقه بیرونی بعد از اولین mismatch\n\n**۶) برگشت اشتباه:**\n- indexOf اگر پیدا نشد → `-1`\n- count اگر پیدا نشد → `0`\n\n**۷) case sensitivity:**\n- اگر گفت case-insensitive → هر دو را lowercase کن\n\n**۸) pattern خالی:**\n- قرارداد رایج: contains → true، indexOf → 0"
    },
    {
      "kind": "variants",
      "text": "**array_contains_index**\n???: ????? ????? ????? ?? ????? ????? `-1`.\nPseudocode: `ContainsIndex(arr, x)`.\n???????: Best `O(1)`, Worst `O(n)`, Space `O(1)`.\n??????:\n- ?? ??? ????? `-1` ???????.\n- ????? ????? ?? ???? ?? ?????.\n\n**array_contains_bool**\n???: ??? ???? ?? ?? `true/false` ????????.\nPseudocode: `ContainsBool(arr, x)`.\n???????: Best `O(1)`, Worst `O(n)`, Space `O(1)`.\n??????:\n- ??? ?? ????? ????? return ??.\n- ?? ????? `false` ?? ?????? ???.\n\n**string_contains_substring**\n???: ???????? ????? ??????? ? ????????? ????? ????.\nPseudocode: `ContainsSubstring(s, p)`.\n???????: Best `O(m)`, Worst `O(n*m)`, Space `O(1)`.\n??????:\n- ????? ?????? ?? `n-m`.\n- ????????? `s[i+j]`.\n\n**string_contains_ci**\n???: ???????? ???? ?????? ?? ????.\nPseudocode: `ContainsSubstringCI(s, p)`.\n???????: Best `O(m)`, Worst `O(n*m)` (+ ??????????), Space `O(n+m)`.\n??????:\n- ?? ?? ???? ?? ?????????? ?? (`toLower`).\n- locale/case ?? ?????? ????.\n\n**prefix_suffix_check**\n???: ??? ????/????? ???? ?? ????? ???.\nPseudocode: `StartsWith(s,p)` / `EndsWith(s,p)`.\n???????: Best/Worst `O(m)`, Space `O(1)`.\n??????:\n- ??? ??? `n < m`.\n- ????? ????? `n-m+i` ?? ???? ????.\n"
    }
  ]
}
