{
  "schema_name": "tutor_asset.explain.v1",
  "version": "1.0",
  "topic": "search_contains",
  "lang": "de",
  "mode": "explain",
  "title": "Search/Contains (Suchen/Enthalten) — FIAE Explain Core v1.0",
  "summary": "**Search/Contains (Suchen/Enthalten)** ist eine Algorithmenfamilie, die **lineare Suche** (linear search) in Arrays oder Strings durchführt. Diese Algorithmen durchlaufen eine Datenstruktur von Anfang bis Ende, um:\n- **Existenzprüfung:** Existiert ein Element/Teilstring? (`contains`)\n- **Positionsfindung:** Wo ist der erste Treffer? (`indexOf`)\n- **Zählung:** Wie oft kommt ein Element/Teilstring vor? (`count`)\n\n**Ziel:** Ein Muster (Pattern) in einer Datensammlung finden oder zählen durch **einen oder mehrere vollständige Durchläufe**.\n\n**Wichtiger Hinweis (Prüfung):** Alle diese Algorithmen sind **lineare Suche** — d.h. sie prüfen Elemente **nacheinander** von Anfang bis Ende (im Gegensatz zu Binary Search, die Sortierung erfordert).",
  "blocks": [
    {
      "kind": "definition",
      "text": "**Search/Contains (Suchen/Enthalten)** ist eine Algorithmenfamilie, die **lineare Suche** (linear search) in Arrays oder Strings durchführt. Diese Algorithmen durchlaufen eine Datenstruktur von Anfang bis Ende, um:\n- **Existenzprüfung:** Existiert ein Element/Teilstring? (`contains`)\n- **Positionsfindung:** Wo ist der erste Treffer? (`indexOf`)\n- **Zählung:** Wie oft kommt ein Element/Teilstring vor? (`count`)\n\n**Ziel:** Ein Muster (Pattern) in einer Datensammlung finden oder zählen durch **einen oder mehrere vollständige Durchläufe**.\n\n**Wichtiger Hinweis (Prüfung):** Alle diese Algorithmen sind **lineare Suche** — d.h. sie prüfen Elemente **nacheinander** von Anfang bis Ende (im Gegensatz zu Binary Search, die Sortierung erfordert).\n"
    },
    {
      "kind": "idea",
      "text": "Stell dir vor, du hast ein **Buch** und suchst nach einem **Wort**:\n\n**Methode 1: Existenz prüfen (contains):**\n- Du blätterst Seite für Seite durch\n- Beim ersten Vorkommen des Worts → stoppst du und sagst \"Gefunden!\"\n- Falls das Buch zu Ende ist und nichts gefunden → sagst du \"Nicht vorhanden\"\n\n**Methode 2: Position finden (indexOf):**\n- Gleiche Vorgehensweise wie Methode 1, aber wenn gefunden, notierst du die **Seitenzahl**\n- Falls nicht gefunden → sagst du \"-1\" (Konvention für \"nicht gefunden\")\n\n**Methode 3: Zählen (count):**\n- Du musst das **gesamte Buch** durchlesen (nicht nur bis zum ersten Treffer)\n- Jedes Mal, wenn du das Wort siehst, addierst du eins\n- Am Ende → gibst du die Gesamtzahl an\n\n**Mentales Bild:** Wie eine Namenssuche in einer langen Liste — wenn du nur wissen willst \"existiert oder nicht\", kannst du stoppen, sobald gefunden. Wenn du wissen willst \"wie oft\", musst du die gesamte Liste durchgehen.\n"
    },
    {
      "kind": "procedure",
      "text": "Search/Contains arbeitet mit einer oder zwei Schleifen:\n\n**1) Einfache Suche (contains_char, count_char):**\n- **Eine Schleife:** Über alle Elemente `i = 0 BIS LAENGE(text)-1`\n- **Vergleich:** Ist `text[i] == target`?\n- **contains:** Erster Treffer → `return true`, Ende der Schleife → `return false`\n- **count:** Jeder Treffer → `count++`, Ende der Schleife → `return count`\n\n**2) Teilstring-Suche (contains_substring, indexOf, count_substring):**\n- **Äußere Schleife:** Über mögliche Startpositionen `i = 0 BIS n-m`\n  * `n = LAENGE(text)`, `m = LAENGE(pattern)`\n  * Hinweis: `n-m` (nicht `n-1`) weil Platz für Pattern nötig\n- **Innere Schleife:** Zeichenweiser Vergleich `j = 0 BIS m-1`\n  * Ist `text[i+j] == pattern[j]`?\n  * Erste Nichtübereinstimmung → `break` und nächste Position versuchen\n- **Falls alle übereinstimmen:**\n  * **contains:** → `return true`\n  * **indexOf:** → `return i`\n  * **count:** → `count++` und **Sprung** zu `i+m` (für nicht-überlappend)\n\n**3) Spezielle Optimierungen (startsWith, endsWith):**\n- **startsWith:** Nur Index 0 wird geprüft (eine Position)\n- **endsWith:** Nur Index `n-m` wird geprüft (eine Position)\n- Keine Suche im gesamten text → schneller `O(m)`\n\n**Prüfungshinweis:** Der Hauptunterschied zwischen Varianten liegt in **Early Return** (vorzeitiger Rückgabe) oder **Komplettdurchlauf**:\n- **contains/indexOf:** Können früh zurückkehren\n- **count:** Muss die gesamte Datenstruktur durchlaufen\n"
    },
    {
      "kind": "example",
      "text": "text=\"hello\" enth?lt \"ll\" ? true, indexOf=2."
    },
    {
      "kind": "complexity",
      "text": "**Komplexität nach Variante:**\n\n**1) Einfache Suche (contains_char, count_char):**\n- Best-case: **O(1)** — Erstes Element stimmt überein (nur für contains)\n- Average-case: **O(n)**\n- Worst-case: **O(n)** — Gesamter text muss geprüft werden\n- `n = LAENGE(text)`\n\n**2) Teilstring-Suche (contains_substring, indexOf, count_substring):**\n- Best-case: **O(m)** — Erste Position stimmt vollständig überein\n- Average-case: **O(n * m)** — Meiste Positionen müssen geprüft werden\n- Worst-case: **O(n * m)** — Beispiel: `text=\"aaaa\"`, `pattern=\"aaab\"` → Jede Position bis zum Ende geprüft\n- `n = LAENGE(text)`, `m = LAENGE(pattern)`\n\n**3) Spezielle Optimierungen (startsWith, endsWith):**\n- Immer: **O(m)** — Nur eine Position wird geprüft\n- `m = LAENGE(pattern)`\n\n**Raum:** **O(1)** — Nur wenige feste Variablen (i, j, count, gefunden)\n\n**Vergleich:**\n- **Schneller als:** Sortieralgorithmen (`O(n log n)` oder `O(n²)`)\n- **Langsamer als:** Binary Search (`O(log n)`) — aber Binary Search erfordert Sortierung\n- **Fortgeschrittenere Algorithmen:** KMP `O(n+m)`, Boyer-Moore — in IHK unüblich\n\n**Prüfungshinweis:** Der naive Algorithmus ist für kurze Strings ausreichend. In IHK typischerweise `n < 100`, `m < 10`.\n"
    },
    {
      "kind": "ihk_traps",
      "text": "**1) Falsche Schleifengrenzen bei Teilstring-Suche (kritisch!):**\n- ❌ `FUER i = 0 BIS n-1` → Versuch, `text[n]` oder mehr zu lesen\n- ✓ `FUER i = 0 BIS n-m` → Nur Positionen, wo Pattern hineinpasst\n- **Grund:** Wenn Pattern Länge 3 hat und text Länge 5, ist letzte gültige Startposition `i=2` (5-3=2)\n\n**2) Falscher Index in innerer Schleife:**\n- ❌ `text[j]` oder `text[i]` statt `text[i+j]`\n- ✓ `text[i+j]` — Startposition `i` + Offset in Pattern `j`\n\n**3) Überlappend vs. nicht-überlappend bei count_substring (häufige Falle!):**\n- **Nicht-überlappend (üblich in IHK):** Nach Treffer `i = i + m`\n  * Beispiel: `text=\"aaaa\", pattern=\"aa\"` → count=2\n- **Überlappend (unüblich):** Nach Treffer `i++`\n  * Gleiches Beispiel → count=3\n- ✓ Aufgabentext genau lesen: \"nicht-überlappend\" oder \"getrennt\" bedeutet üblicherweise Sprung `i+m`\n\n**4) Vergessenes Early Return bei contains/indexOf:**\n- ❌ `gefunden = true` aber Schleife läuft weiter\n- ✓ Sofort `GIB true ZURUECK` oder `GIB i ZURUECK`\n- **Folge:** Code funktioniert, ist aber langsam (gesamter text wird geprüft)\n\n**5) Falscher Einsatz von break:**\n- In **innerer** Schleife: ✓ break wenn `text[i+j] != pattern[j]` → nächste Position versuchen\n- In **äußerer** Schleife: ❌ break nach erster Nichtübereinstimmung → Algorithmus komplett falsch\n\n**6) Falsche Rückgabe bei count:**\n- ❌ `return true/false` statt `return count`\n- ❌ `return -1` für \"nicht gefunden\" (das ist nur für indexOf)\n- ✓ `return 0` wenn keine Treffer (immer Ganzzahl)\n\n**7) Vergessener Sonderfall: leeres Pattern:**\n- Üblicherweise Konvention:\n  * **contains:** `return true` (leerer Teilstring existiert immer)\n  * **indexOf:** `return 0` (leerer Teilstring wird bei Index 0 gefunden)\n  * **count:** `return 0` oder unendlich (abhängig von Definition)\n- ✓ Prüfung `WENN LAENGE(pattern) == 0` am Anfang\n\n**8) Case-Sensitivity (Groß-/Kleinschreibung):**\n- Normaler Vergleich `==` ist case-sensitive\n- `'a' != 'A'` in ASCII/Unicode\n- Falls Aufgabe \"case-insensitive\" verlangt → Alle zu lowercase konvertieren\n\n**9) Fehler bei startsWith/endsWith-Berechnung:**\n- **startsWith:** Start bei `i=0`\n- **endsWith:** Start bei `i = n - m`\n- ❌ `i = n - m - 1` oder `i = n - m + 1` → Off-by-one-Error\n\n**10) Falsche Komplexität:**\n- ❌ `O(n)` für Teilstring-Suche sagen → falsch, ist `O(n*m)`\n- ❌ `O(n²)` für contains_char sagen → falsch, ist `O(n)`\n- ✓ Einfache Suche: `O(n)`, Teilstring: `O(n*m)`, startsWith/endsWith: `O(m)`\n"
    },
    {
      "kind": "variants",
      "text": "**array_contains_index**\nZiel: Ersten Trefferindex im Array liefern, sonst `-1`.\nPseudocode: `ContainsIndex(arr, x)`.\nKomplexit?t: Best `O(1)`, Worst `O(n)`, Space `O(1)`.\nTraps:\n- `-1` bei nicht gefunden.\n- Nicht letzten statt ersten Treffer zur?ckgeben.\n\n**array_contains_bool**\nZiel: Nur Existenz als `true/false` zur?ckgeben.\nPseudocode: `ContainsBool(arr, x)`.\nKomplexit?t: Best `O(1)`, Worst `O(n)`, Space `O(1)`.\nTraps:\n- Fr?h return bei Treffer.\n- `false` am Ende nicht vergessen.\n\n**string_contains_substring**\nZiel: Naive Substring-Suche, Startindex zur?ckgeben.\nPseudocode: `ContainsSubstring(s, p)`.\nKomplexit?t: Best `O(m)`, Worst `O(n*m)`, Space `O(1)`.\nTraps:\n- ?u?ere Schleife bis `n-m`.\n- Indexierung `s[i+j]`.\n\n**string_contains_ci**\nZiel: Substring-Suche ohne Gro?-/Kleinschreibung.\nPseudocode: `ContainsSubstringCI(s, p)`.\nKomplexit?t: Best `O(m)`, Worst `O(n*m)` (+ Normalisierung), Space `O(n+m)`.\nTraps:\n- Beide Strings normalisieren (`toLower`).\n- Locale/Case-Fallen beachten.\n\n**prefix_suffix_check**\nZiel: Nur Prefix/Suffix pr?fen (startsWith/endsWith).\nPseudocode: `StartsWith(s,p)` / `EndsWith(s,p)`.\nKomplexit?t: Best/Worst `O(m)`, Space `O(1)`.\nTraps:\n- L?ngencheck `n < m`.\n- End-Index `n-m+i` korrekt.\n"
    }
  ]
}
