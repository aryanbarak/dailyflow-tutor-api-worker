{
  "schema_name": "tutor_asset.explain.v1",
  "version": "1.0",
  "topic": "binarysearch",
  "lang": "fa",
  "mode": "explain",
  "title": "Binary Search (جستجوی دودویی) — FIAE Core (فارسی)",
  "summary": "**جستجوی دودویی** (Binary Search) یک الگوریتم کارآمد برای پیدا کردن یک مقدار در آرایه **مرتب شده** است.\n\n**اصل کار:** تقسیم و غلبه (Divide & Conquer) – در هر مرحله، فضای جستجو نصف می‌شود.\n\n**پیش‌شرط:** آرایه باید **مرتب** باشد (صعودی یا نزولی).\n\n**پیچیدگی زمانی:** `O(log n)` – بسیار سریع‌تر از جستجوی خطی (`O(n)`).\n\n**پیچیدگی مکانی:**\n- تکراری: `O(1)`\n- بازگشتی: `O(log n)` (به دلیل Call Stack)",
  "blocks": [
    {
      "kind": "definition",
      "text": "**جستجوی دودویی** (Binary Search) یک الگوریتم کارآمد برای پیدا کردن یک مقدار در آرایه **مرتب شده** است.\n\n**اصل کار:** تقسیم و غلبه (Divide & Conquer) – در هر مرحله، فضای جستجو نصف می‌شود.\n\n**پیش‌شرط:** آرایه باید **مرتب** باشد (صعودی یا نزولی).\n\n**پیچیدگی زمانی:** `O(log n)` – بسیار سریع‌تر از جستجوی خطی (`O(n)`).\n\n**پیچیدگی مکانی:**\n- تکراری: `O(1)`\n- بازگشتی: `O(log n)` (به دلیل Call Stack)\n"
    },
    {
      "kind": "idea",
      "text": "**روش کار (امتحانی):**\n- عنصر وسط (`arr[mid]`) را با مقدار هدف (`target`) مقایسه کن.\n- اگر `arr[mid] == target` → **پیدا شد** → اندیس `mid` را برگردان.\n- اگر `arr[mid] < target` → نیمه راست (`low = mid + 1`).\n- اگر `arr[mid] > target` → نیمه چپ (`high = mid - 1`).\n- تکرار تا وقتی `low > high` → **پیدا نشد**.\n\n**چرا سریع است؟**\n- هر مرحله تعداد گزینه‌ها **نصف** می‌شود.\n- برای `n = 1,000,000` حداکثر حدود `20` مقایسه لازم است (`log2(n)`).\n"
    },
    {
      "kind": "procedure",
      "text": "**مثال ۱:** جستجوی `target = 7` در `arr = [1, 3, 5, 7, 9, 11, 13]`\n- `low=0`, `high=6`, `mid=3`\n- `arr[3]=7` → **یافت شد** → برگشت `3`\n\n**مثال ۲:** جستجوی `target = 10` در `arr = [1, 3, 5, 7, 9, 11, 13]`\n- مرحله ۱: `low=0`, `high=6`, `mid=3` → `arr[3]=7 < 10` → `low=4`\n- مرحله ۲: `low=4`, `high=6`, `mid=5` → `arr[5]=11 > 10` → `high=4`\n- مرحله ۳: `low=4`, `high=4`, `mid=4` → `arr[4]=9 < 10` → `low=5`\n- مرحله ۴: `low=5`, `high=4` → `low > high` → برگشت `-1`\n"
    },
    {
      "kind": "example",
      "text": "جستجوی `target=7` در `arr=[1,3,5,7,9]` نتیجه `index=3` می‌دهد."
    },
    {
      "kind": "complexity",
      "text": "**پیچیدگی زمانی:**\n- Best-Case: `O(1)`\n- Average/Worst-Case: `O(log n)`\n\n**پیچیدگی مکانی:**\n- تکراری: `O(1)`\n- بازگشتی: `O(log n)`\n\n**ویژگی‌های مهم:**\n- پیش‌شرط: آرایه باید مرتب باشد.\n- نسخه کلاسیک: اگر پیدا نشد → `-1`.\n- در صورت تکرار (Duplicates): نسخه کلاسیک می‌تواند یک اندیس دلخواه برگرداند (غیرقطعی).\n"
    },
    {
      "kind": "ihk_traps",
      "text": "**دام ۱: آرایه مرتب نیست**\n- Binary Search فقط روی آرایه مرتب درست است.\n\n**دام ۲: شرط حلقه**\n- کلاسیک: `low <= high` (با برابری)\n- اگر `low < high` بنویسی ممکن است آخرین عنصر چک نشود.\n\n**دام ۳: محاسبه mid**\n- استاندارد: `mid = (low + high) DIV 2`\n- ایمن‌تر (Bonus): `mid = low + (high - low) DIV 2`\n\n**دام ۴: آپدیت low/high اشتباه**\n- درست: `low = mid + 1` و `high = mid - 1`\n- غلط: `low = mid` یا `high = mid` → ممکن است حلقه بی‌نهایت شود.\n\n**دام ۵: تکرارها (Duplicates)**\n- کلاسیک: اندیس غیرقطعی\n- first_occurrence: به چپ ادامه بده (`high = mid - 1`)\n- last_occurrence: به راست ادامه بده (`low = mid + 1`)\n"
    },
    {
      "kind": "variants",
      "text": "**classic_iterative**: نسخه تکراری استاندارد. پیچیدگی زمانی `O(log n)` و فضایی `O(1)`.\n**classic_recursive**: نسخه بازگشتی با شرط پایه `links > rechts`. زمان `O(log n)` و فضای پشته `O(log n)`.\n**objects_by_key**: جستجو روی `a[mid][key]`؛ آرایه باید بر اساس همان `key` مرتب باشد.\n**generic_comparator**: مقایسه با `cmp(a,b)` برای انواع داده سفارشی.\n**safe_mid**: محاسبه امن `mid = low + (high-low)/2` برای جلوگیری از overflow.\n**trace_exam**: نسخه مناسب ردگیری امتحانی با ثبت `low/mid/high`.\n**debug_common_errors**: چک‌لیست خطاهای رایج: مرتب‌بودن آرایه، شرط حلقه، محاسبه mid، آپدیت low/high، خروجی -1.\n"
    }
  ]
}
