{
  "schema_name": "tutor_asset.explain.v1",
  "version": "1.0",
  "topic": "insertionsort",
  "lang": "fa",
  "mode": "explain",
  "title": "InsertionSort (مرتب‌سازی درجی) — FIAE Explain Core v1.0",
  "summary": "**InsertionSort (مرتب‌سازی درجی)** یک الگوریتم مرتب‌سازی ساده است که در هر دور، **عنصر بعدی از بخش نامرتب** را برمی‌دارد و آن را **در جای درست خود در بخش مرتب‌شده** قرار می‌دهد.\n\n**اصل:**\n- آرایه به دو بخش تقسیم می‌شود: **مرتب‌شده** (چپ) و **نامرتب** (راست)\n- در هر دور i (از i=1 شروع می‌شود):\n  - عنصر a[i] برداشته می‌شود (key)\n  - عناصر بزرگ‌تر از key یک خانه به راست **شیفت** می‌خورند (نه swap)\n  - key در جای خالی قرار می‌گیرد\n- بخش مرتب‌شده گام به گام بزرگ‌تر می‌شود\n\n**نام:** مثل مرتب کردن کارت‌های بازی در دست — کارت جدید را برمی‌داری و بین کارت‌های مرتب‌شده قبلی جا می‌دهی.\n\n**اهمیت IHK:**\n- اغلب در امتحانات: دنبال کردن وضعیت بعد از هر دور i\n- Loop-Invariant: بعد از دور i، اولین i+1 عنصر مرتب‌اند (ولی نه قطعی!)\n- تفاوت Shift vs Swap\n- Best-Case O(n) برای آرایه‌های تقریباً مرتب (تطبیقی/Adaptive)",
  "blocks": [
    {
      "kind": "definition",
      "text": "**InsertionSort (مرتب‌سازی درجی)** یک الگوریتم مرتب‌سازی ساده است که در هر دور، **عنصر بعدی از بخش نامرتب** را برمی‌دارد و آن را **در جای درست خود در بخش مرتب‌شده** قرار می‌دهد.\n\n**اصل:**\n- آرایه به دو بخش تقسیم می‌شود: **مرتب‌شده** (چپ) و **نامرتب** (راست)\n- در هر دور i (از i=1 شروع می‌شود):\n  - عنصر a[i] برداشته می‌شود (key)\n  - عناصر بزرگ‌تر از key یک خانه به راست **شیفت** می‌خورند (نه swap)\n  - key در جای خالی قرار می‌گیرد\n- بخش مرتب‌شده گام به گام بزرگ‌تر می‌شود\n\n**نام:** مثل مرتب کردن کارت‌های بازی در دست — کارت جدید را برمی‌داری و بین کارت‌های مرتب‌شده قبلی جا می‌دهی.\n\n**اهمیت IHK:**\n- اغلب در امتحانات: دنبال کردن وضعیت بعد از هر دور i\n- Loop-Invariant: بعد از دور i، اولین i+1 عنصر مرتب‌اند (ولی نه قطعی!)\n- تفاوت Shift vs Swap\n- Best-Case O(n) برای آرایه‌های تقریباً مرتب (تطبیقی/Adaptive)"
    },
    {
      "kind": "idea",
      "text": "**ایده:** بخش مرتب‌شده از چپ شروع می‌شود و گام به گام بزرگ‌تر می‌شود.\n\n**روند:**\n1. **شروع:** عنصر اول (i=0) قبلاً «مرتب» است → حلقه از i=1 شروع می‌شود\n2. **دور i:** عنصر a[i] را بردار (key)\n3. **جستجو:** از راست به چپ در بخش مرتب (0..i-1) حرکت کن:\n   - تا وقتی a[j] > key: عنصر a[j] را یک خانه به راست شیفت بده\n   - وقتی a[j] ≤ key یا j < 0: جای درست پیدا شده\n4. **درج:** key را در موقعیت j+1 قرار بده\n5. **تکرار** تا تمام عناصر پردازش شوند\n\n**مهم برای IHK:**\n- **Loop-Invariant:** بعد از دور i، اولین i+1 عنصر مرتب‌اند\n- **Shift vs Swap:** InsertionSort شیفت می‌کند (a[j+1] = a[j])، مبادله نمی‌کند\n- **تطبیقی (Adaptive):** برای آرایه‌های تقریباً مرتب سریع است (Best-Case O(n))\n- **پایدار (Stable):** عناصر برابر ترتیب نسبی خود را حفظ می‌کنند"
    },
    {
      "kind": "procedure",
      "text": "**مثال:** arr = [12, 11, 13, 5, 6]\n\n**شروع:** بخش مرتب = [12] (یک عنصر قبلاً مرتب است)\n\n**دور i = 1:**\n- key = 11، j = 0\n- a[0]=12 > 11 → شیفت 12 به راست: a[1] = 12\n- j = -1 (توقف)\n- key در j+1 = 0: a[0] = 11\n- **نتیجه:** [11, 12, 13, 5, 6]\n\n**دور i = 2:**\n- key = 13، j = 1\n- a[1]=12 < 13 → شیفت لازم نیست\n- key در j+1 = 2: a[2] = 13 (همان‌جا)\n- **نتیجه:** [11, 12, 13, 5, 6]\n\n**دور i = 3:**\n- key = 5، j = 2\n- a[2]=13 > 5 → شیفت: a[3] = 13، j = 1\n- a[1]=12 > 5 → شیفت: a[2] = 12، j = 0\n- a[0]=11 > 5 → شیفت: a[1] = 11، j = -1\n- key در j+1 = 0: a[0] = 5\n- **نتیجه:** [5, 11, 12, 13, 6]\n\n**دور i = 4:**\n- key = 6، j = 3\n- a[3]=13 > 6 → شیفت: a[4] = 13، j = 2\n- a[2]=12 > 6 → شیفت: a[3] = 12، j = 1\n- a[1]=11 > 6 → شیفت: a[2] = 11، j = 0\n- a[0]=5 < 6 → توقف\n- key در j+1 = 1: a[1] = 6\n- **نتیجه نهایی:** [5, 6, 11, 12, 13]\n\n**جمع:**\n- تعداد دورها: n-1 = 4\n- مقایسه‌ها (این مثال): 1 + 1 + 3 + 3 = 8\n- شیفت‌ها: 1 + 0 + 3 + 3 = 7"
    },
    {
      "kind": "example",
      "text": "```text\nPROZEDUR InsertionSort(a)\n  n = LAENGE(a)\n  FUER i = 1 BIS n-1\n    key = a[i]\n    j = i - 1\n    SOLANGE j >= 0 UND a[j] > key\n      a[j+1] = a[j]  // Shift (nicht Swap!)\n      j = j - 1\n    ENDE\n    a[j+1] = key  // Einfügen\n  ENDE\n  GIB a ZURUECK\nENDE\n```\n\n**نکات کلیدی:**\n- حلقه بیرونی از i=1 شروع می‌شود (نه i=0)\n- key = a[i] — عنصر برداشته‌شده\n- حلقه داخلی: j >= 0 **و** a[j] > key\n- شیفت: a[j+1] = a[j] (نه swap)\n- درج: a[j+1] = key (نه a[j])"
    },
    {
      "kind": "complexity",
      "text": "**زمان (Time):**\n- **Best-Case:** O(n)\n  - وقتی آرایه قبلاً (تقریباً) مرتب است\n  - حلقه داخلی فقط یک مقایسه در هر دور انجام می‌دهد\n  - InsertionSort **تطبیقی (Adaptive)** است\n- **Average-Case:** O(n²)\n  - به‌طور متوسط n²/4 مقایسه و شیفت\n- **Worst-Case:** O(n²)\n  - وقتی آرایه معکوس مرتب‌شده است\n  - برای هر عنصر i، باید i شیفت انجام شود\n  - مقایسه‌ها: 1+2+3+...+(n-1) = n(n-1)/2\n\n**حافظه (Space):**\n- O(1) — فقط متغیرهای i, j, key\n- الگوریتم **In-Place** است\n\n**شیفت‌ها (Shifts):**\n- Best-Case: 0 (هیچ شیفتی لازم نیست)\n- Worst-Case: n(n-1)/2 (همه عناصر باید شیفت بخورند)\n\n**پایداری (Stability):**\n- InsertionSort **پایدار است**\n- شرط a[j] > key (نه >=) ترتیب نسبی عناصر برابر را حفظ می‌کند\n- برای secondary/tertiary sort مفید است"
    },
    {
      "kind": "ihk_traps",
      "text": "**1) حلقه بیرونی از i=0 شروع می‌شود:**\n- ❌ **غلط!** باید از i=1 شروع شود\n- دلیل: یک عنصر قبلاً «مرتب» است\n\n**2) مقایسه با a[i] به‌جای key:**\n- ❌ **غلط!** key عنصر برداشته‌شده است، نه a[i]\n- a[i] در حین شیفت تغییر می‌کند!\n\n**3) استفاده از Swap به‌جای Shift:**\n- ❌ **غلط!** InsertionSort شیفت می‌کند (a[j+1] = a[j])\n- Swap دو عنصر را مبادله می‌کند — متفاوت است\n\n**4) پایداری اشتباه:**\n- ✓ InsertionSort پایدار است (برخلاف SelectionSort)\n- شرط a[j] > key (نه >=) حیاتی است\n- اگر >= استفاده شود، پایداری از بین می‌رود\n\n**5) Best-Case اشتباه:**\n- ❌ **غلط:** Best-Case O(n²) است\n- ✓ **درست:** Best-Case O(n) برای آرایه‌های تقریباً مرتب\n- InsertionSort تطبیقی است!\n\n**6) شرط توقف j:**\n- ❌ **غلط:** فقط a[j] > key بررسی شود\n- ✓ **درست:** j >= 0 **و** a[j] > key\n- بدون j >= 0 → Index-Out-of-Bounds!\n\n**7) جای درج:**\n- ❌ **غلط:** key در موقعیت j قرار می‌گیرد\n- ✓ **درست:** key در موقعیت j+1 قرار می‌گیرد\n\n**8) Loop-Invariant:**\n- بعد از دور i: اولین i+1 عنصر مرتب‌اند\n- **ولی:** لزوماً در جای قطعی خود نیستند!\n- تفاوت با SelectionSort: SelectionSort عناصر را قطعی می‌کند\n\n**9) Shift vs Swap (بسیار رایج در امتحان!):**\n- Shift: یک عنصر یک خانه جابجا می‌شود\n- Swap: دو عنصر با هم مبادله می‌شوند\n- InsertionSort: Shift\n- BubbleSort/SelectionSort: Swap\n\n**10) Binary InsertionSort:**\n- تعداد مقایسه‌ها: O(n log n)\n- **ولی:** شیفت‌ها هنوز O(n²)\n- **زمان کلی:** همچنان O(n²) — فقط ثابت بهتر می‌شود\n- دام: فکر کردن زمان کلی O(n log n) می‌شود!"
    },
    {
      "kind": "variants",
      "text": "**قانون ثابت در همه نسخه‌ها:**\n- الگو یکسان است: «عنصر را بردار» + «در جای درست با shift قرار بده»\n- نسخه‌ها فقط در **منطق مقایسه** یا **نوع داده** فرق دارند\n\n**1) Classic (classic_int_asc):**\n- آرایه عدد صحیح، صعودی\n- مقایسه: a[j] > key\n- دام: حلقه از i=1 شروع می‌شود\n- پایداری: شرط > (نه >=)\n\n**2) Optimized Shift (optimized_shift):**\n- همان کلاسیک، تأکید روی ویژگی تطبیقی\n- Best-Case: O(n) برای آرایه‌های تقریباً مرتب\n- Worst-Case: هنوز O(n²)\n- دام: فکر کردن Worst-Case بهتر می‌شود\n\n**3) Comparator Function (comparator_f):**\n- استفاده از تابع مقایسه f(a,b)\n- قانون: f(a,b) < 0 → a قبل b، f(a,b) > 0 → b قبل a\n- شرط shift: f(a[j], key) > 0\n- مثال: صعودی f(a,b) = a-b، نزولی f(a,b) = b-a\n- Separation of Concerns\n\n**4) Strings (strings_lex):**\n- مرتب‌سازی رشته‌ها\n- مقایسه با compare(a,b) (لغوی/lexikografisch)\n- دام: case حساس است (A ≠ a)\n- Umlautها (ä, ö, ü) ترتیب خاص دارند\n\n**5) Objects by Field (objects_by_field):**\n- مرتب‌سازی آبجکت‌ها بر اساس یک فیلد\n- مقایسه: a[j][field] > key_obj[field]\n- **دام رایج:** shift کردن فقط a[j][field] — باید کل آبجکت shift شود!\n- key_obj کل آبجکت است\n- پایداری برای multi-level sort مفید\n\n**6) Generic Concept (generic_concept):**\n- نسخهٔ کلی برای هر نوع داده\n- الگوریتم ثابت، Comparator آن را مستقل می‌کند\n- Separation of Concerns، Generic <T>\n- Comparator باید سه‌حالته باشد (منفی/صفر/مثبت)\n- دام: برگرداندن boolean به‌جای عدد\n\n**7) Binary Insertion (binary_insertion_bonus):**\n- جای درج با Binary Search پیدا می‌شود\n- مقایسه‌ها: O(n log n) — کاهش می‌یابد\n- **ولی:** شیفت‌ها هنوز O(n²)\n- **زمان کلی:** همچنان O(n²)\n- **دام بزرگ:** فکر کردن زمان کلی O(n log n) می‌شود!\n- فقط اگر مقایسه‌ها بسیار گران باشند مفید است"
    }
  ]
}
