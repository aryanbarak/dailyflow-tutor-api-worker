{
  "schema_name": "tutor_asset.explain.v1",
  "version": "1.0",
  "topic": "selectionsort",
  "lang": "fa",
  "mode": "explain",
  "title": "SelectionSort (مرتب‌سازی انتخابی) — FIAE Explain Core v1.0",
  "summary": "**SelectionSort (مرتب‌سازی انتخابی)** الگوریتمی است که در هر دور، **یک عنصر «بهترین»** (در نسخه کلاسیک: کوچک‌ترین عنصر) را از بخش نامرتب پیدا می‌کند و آن را به ابتدای همان بخش منتقل می‌کند.\n\n**هدف:** مرتب‌سازی آرایه با **حداقل تعداد swap**، در حالی که **تعداد مقایسه‌ها در همه حالت‌ها زیاد و تقریباً ثابت** است.\n\n**نکته کلیدی (امتحانی):** بعد از پایان دور `i`، عنصر `a[i]` در جای درست خودش قرار گرفته و **دیگر تغییر نمی‌کند**؛ یعنی اولین `i+1` عنصر قطعی و مرتب هستند.",
  "blocks": [
    {
      "kind": "definition",
      "text": "**SelectionSort (مرتب‌سازی انتخابی)** الگوریتمی است که در هر دور، **یک عنصر «بهترین»** (در نسخه کلاسیک: کوچک‌ترین عنصر) را از بخش نامرتب پیدا می‌کند و آن را به ابتدای همان بخش منتقل می‌کند.\n\n**هدف:** مرتب‌سازی آرایه با **حداقل تعداد swap**، در حالی که **تعداد مقایسه‌ها در همه حالت‌ها زیاد و تقریباً ثابت** است.\n\n**نکته کلیدی (امتحانی):** بعد از پایان دور `i`، عنصر `a[i]` در جای درست خودش قرار گرفته و **دیگر تغییر نمی‌کند**؛ یعنی اولین `i+1` عنصر قطعی و مرتب هستند.\n"
    },
    {
      "kind": "idea",
      "text": "آرایه را از نظر ذهنی به دو بخش تقسیم کن:\n- **بخش مرتب‌شده:** `0 .. i-1` (در هر دور بزرگ‌تر می‌شود)\n- **بخش نامرتب:** `i .. n-1` (در هر دور کوچک‌تر می‌شود)\n\nدر هر دور `i`:\n1) در بخش نامرتب `i .. n-1` دنبال **کمینه** می‌گردیم و اندیس آن را در `minIndex` نگه می‌داریم.\n2) اگر `minIndex` برابر `i` نبود، عنصر کمینه را با `a[i]` جابه‌جا می‌کنیم.\n3) نتیجه: عنصر `a[i]` از این لحظه به بعد **قطعی** است.\n\n**تصویر ذهنی:** سمت چپ آرایه مرتب می‌شود، سمت راست هنوز نامرتب است.\n"
    },
    {
      "kind": "procedure",
      "text": "SelectionSort با دو حلقه کار می‌کند:\n\n**۱) حلقه بیرونی (دورها):**\n- `i` از 0 تا `n-2` حرکت می‌کند.\n- در هر دور، هدف این است که **بهترین عنصر** از بازه `i .. n-1` پیدا شود و در موقعیت `i` قرار بگیرد.\n\n**۲) حلقه داخلی (پیدا کردن کمینه):**\n- ابتدا فرض می‌کنیم کمینه همین عنصر `i` است: `minIndex = i`.\n- سپس همه عناصر بعد از `i` بررسی می‌شوند (از `i+1` تا `n-1`).\n- هر جا عنصر کوچک‌تری دیدیم، `minIndex` را به همان اندیس تغییر می‌دهیم.\n\n**۳) جابه‌جایی (swap شرطی):**\n- اگر در پایان دور، `minIndex ≠ i` بود یعنی کمینه جای دیگری است.\n- فقط در این حالت swap انجام می‌دهیم تا از **جابجایی بی‌فایده** جلوگیری شود.\n\n**نکته امتحانی:** حتی اگر آرایه از قبل مرتب باشد، SelectionSort همچنان کل بازه را می‌گردد؛ یعنی best-case هم `O(n²)` است.\n"
    },
    {
      "kind": "example",
      "text": "????? [64,25,12,22,11] ? ?? ?? ??? ???? 11 ?? ????? 0 ???? ???????."
    },
    {
      "kind": "complexity",
      "text": "**زمان (Time):**\n- SelectionSort تقریباً همیشه تعداد مقایسه‌ی ثابتی انجام می‌دهد:\n  - `(n-1) + (n-2) + ... + 1 = n(n-1)/2` ⇒ `O(n²)`\n- **Best-Case هم `O(n²)` است** چون باید در هر دور کمینه را جستجو کند و Early-Exit ندارد.\n\n**حافظه (Space):**\n- `O(1)` چون فقط چند متغیر مانند `i`, `j`, `minIndex` و یک متغیر موقت برای swap نیاز دارد.\n- الگوریتم **In-Place** است.\n\n**Swap‌ها:**\n- حداکثر `n-1` بار (در هر دور حداکثر یک swap)\n- در بهترین حالت (آرایه مرتب)، ممکن است **0 swap** باشد، ولی مقایسه‌ها همچنان زیاد است.\n\n**پایداری (Stability):**\n- نسخه کلاسیک معمولاً **پایدار نیست** چون swap می‌تواند ترتیب عناصر برابر را تغییر دهد.\n"
    },
    {
      "kind": "ihk_traps",
      "text": "1) **minIndex باید از i شروع شود** نه از 0.\n2) **حلقه داخلی باید از i+1 شروع شود** نه از 0 و نه از i.\n3) **مقایسه باید با a[minIndex] انجام شود** (نه با a[i]).\n4) **swap شرطی**: اگر `minIndex == i` است، swap لازم نیست.\n5) **Best-Case اشتباه**: SelectionSort در بهترین حالت هم `O(n²)` است.\n6) **پایداری**: کلاسیک پایدار نیست (اگر گفتی stable است، غلط است).\n7) **برای Objects** باید **کل آبجکت** جابه‌جا شود، نه فقط مقدار یک فیلد.\n8) **حداکثر swap**: دقیقاً `n-1` (نکته‌ی مقایسه‌ای مهم با Bubble/Insertion).\n"
    },
    {
      "kind": "variants",
      "text": "**classic_int_asc**\n???: ????? ?? ?? ???? ???? ? ?? ?? ?????? (?????).\nPseudocode: `SelectionSort(a)`.\n???????: Best `O(n^2)`, Worst `O(n^2)`.\n??????:\n- `minIndex` ???? ?? `i` ???? ???.\n- Best-Case ?????? `O(n^2)` ???.\n\n**comparator_f**\n???: ?????? ?? `f(a,b)`.\nPseudocode: `SelectionSort(a, f)`.\n???????: Best `O(n^2)`, Worst `O(n^2)` (?????? ?????? ????).\n??????:\n- `f(a,b) < 0` ???? `a` ??? ?? `b`.\n- ????? ?????????? `f` ?? ????? ???.\n\n**strings**\n???: ????????? ???? ???????.\nPseudocode: `SelectionSort_Strings(a)`.\n???????: Best `O(n^2)`, Worst `O(n^2)` (?????? ?? ??? ????).\n??????:\n- ?????? ?? ???? ? locale.\n- ??????? ???? ?? ???? ??? ???.\n\n**objects**\n???: ????????? ???????? ?? ???? `key`.\nPseudocode: `SelectionSort_Objects(a, key)`.\n???????: Best `O(n^2)`, Worst `O(n^2)`.\n??????:\n- ???? ?? ????? swap ???.\n- ?????? `key` ??????.\n\n**generic**\n???: ????? ????? ?? Comparator `comp`.\nPseudocode: `SelectionSort_Generic(a, comp)`.\n???????: Best `O(n^2)`, Worst `O(n^2)`.\n??????:\n- ??? Comparator ?? ?????? ?????.\n- ???? `comp(a,b) < 0` ?? ??? ????? ???.\n\n**stable_shift_variant**\n???: ?????? ???? ?? shift ?????? swap.\nPseudocode: `SelectionSort_Stable(a)`.\n???????: Best `O(n^2)`, Worst `O(n^2)` (??????? ?????).\n??????:\n- ????? ?????? ?? ?????? ??? ???.\n- ???? shift ?? ??? ????.\n\n**minmax_variant**\n???: ?? ?? ??? ?? ????? ?? ?????? ?? ????????? ???.\nPseudocode: `SelectionSort_MinMax(a)`.\n???????: Best `O(n^2)`, Worst `O(n^2)`.\n??????:\n- ?????? `links`/`rechts` ???? ??????????? ????.\n- ??? ??? ?? swap ??? `maxIdx` ????? ??? ????? ???.\n"
    }
  ]
}
