{
  "schema_name": "tutor_asset.explain.v1",
  "version": "1.0",
  "topic": "checksum",
  "lang": "fa",
  "mode": "explain",
  "title": "رقم بررسی (Checksum / Prüfziffer) — FIAE Explain Core v1.0",
  "summary": "**رقم بررسی (Checksum / Prüfziffer)** روشی است برای **تشخیص خطا در داده‌ها** که با محاسبه یک رقم اضافی از روی ارقام اصلی، امکان تأیید صحت کد را فراهم می‌کند.\n\n**هدف:** جلوگیری از خطاهای تایپ، جابه‌جایی ارقام، یا تغییرات تصادفی در کدهای مهم مانند:\n- شماره‌های ISBN (کتاب‌ها)\n- کدهای EAN/UPC (محصولات)\n- شماره‌های کارت اعتباری (Luhn)\n- شماره‌های حساب بانکی (IBAN)\n\n**نکته کلیدی (امتحانی):** رقم بررسی **از روی سایر ارقام محاسبه می‌شود** و نمی‌تواند دلبخواهی باشد. دو عملیات اصلی:\n1. **Build (ساخت):** از کد بدون رقم بررسی → کد کامل با رقم بررسی\n2. **Validate (اعتبارسنجی):** کد کامل → آیا صحیح است؟",
  "blocks": [
    {
      "kind": "definition",
      "text": "**رقم بررسی (Checksum / Prüfziffer)** روشی است برای **تشخیص خطا در داده‌ها** که با محاسبه یک رقم اضافی از روی ارقام اصلی، امکان تأیید صحت کد را فراهم می‌کند.\n\n**هدف:** جلوگیری از خطاهای تایپ، جابه‌جایی ارقام، یا تغییرات تصادفی در کدهای مهم مانند:\n- شماره‌های ISBN (کتاب‌ها)\n- کدهای EAN/UPC (محصولات)\n- شماره‌های کارت اعتباری (Luhn)\n- شماره‌های حساب بانکی (IBAN)\n\n**نکته کلیدی (امتحانی):** رقم بررسی **از روی سایر ارقام محاسبه می‌شود** و نمی‌تواند دلبخواهی باشد. دو عملیات اصلی:\n1. **Build (ساخت):** از کد بدون رقم بررسی → کد کامل با رقم بررسی\n2. **Validate (اعتبارسنجی):** کد کامل → آیا صحیح است؟\n"
    },
    {
      "kind": "idea",
      "text": "**مدل ریاضی پایه:**\n- هر رقم در کد یک **وزن (weight)** دارد.\n- **مجموع وزن‌دار** تمام ارقام را حساب می‌کنیم: `sum = Σ(digit[i] × weight[i])`\n- یک **عمل مدولو** (معمولاً Mod 10 یا Mod 11) انجام می‌دهیم.\n- رقم بررسی طوری انتخاب می‌شود که **مجموع کل بخش‌پذیر بر عدد مدولو باشد**.\n\n**سه نسخه رایج:**\n\n**1) Quersumme (جمع ساده):**\n- وزن همه ارقام = 1\n- فقط جمع می‌کنیم: `1+2+3+4 = 10`\n- بدون فرمول پیچیده\n\n**2) Mod-10 با وزن:**\n- وزن‌ها متناوب یا ثابت: مثلاً `[2, 1, 2, 1, ...]` یا `[1, 3, 1, 3, ...]`\n- فرمول نهایی: `check = (10 - sum % 10) % 10`\n\n**3) Mod-11 (ISBN-10):**\n- وزن‌های کاهشی: `[10, 9, 8, 7, 6, 5, 4, 3, 2]`\n- فرمول: `check = (11 - sum % 11) % 11`\n- رقم بررسی می‌تواند 0-9 یا 'X' (= 10) باشد\n\n**تصویر ذهنی:** فکر کن هر رقم یک \"سنگ\" با وزن مشخص است؛ همه را جمع می‌کنیم و باقیمانده تقسیم بر 10 یا 11 را بررسی می‌کنیم.\n"
    },
    {
      "kind": "procedure",
      "text": "**الگوریتم Build (ساخت رقم بررسی):**\n\n**گام 1) مقداردهی اولیه:**\n- `sum = 0`\n- `weights` = آرایه وزن‌ها (مثلاً `[2, 1]` یا `[10, 9, 8, ...]`)\n\n**گام 2) محاسبه مجموع وزن‌دار:**\n- برای هر رقم در کد (از چپ به راست یا راست به چپ، بسته به استاندارد):\n  - `digit = int(code[i])`\n  - `weight = weights[i % len(weights)]` (تناوب برای کدهای طولانی)\n  - `sum += digit × weight`\n\n**گام 3) محاسبه باقیمانده:**\n- `rest = sum % 10` (یا `% 11` برای Mod-11)\n\n**گام 4) محاسبه رقم بررسی:**\n- **Mod-10:** `check = (10 - rest) % 10`\n- **Mod-11:** `check = (11 - rest) % 11` (اگر 10 شد → 'X')\n\n**گام 5) برگرداندن نتیجه:**\n- کد کامل = `prefix + str(check)`\n\n---\n\n**الگوریتم Validate (اعتبارسنجی):**\n\n**گام 1) جدا کردن prefix و check:**\n- `prefix = code[:-1]` (همه ارقام بجز آخری)\n- `given_check = int(code[-1])` (آخرین رقم)\n\n**گام 2) محاسبه رقم بررسی مورد انتظار:**\n- از همان الگوریتم Build استفاده کن، ولی فقط با `prefix`\n- `expected_check = calculate_check(prefix)`\n\n**گام 3) مقایسه:**\n- معتبر ⇔ `given_check == expected_check`\n\n**نکته امتحانی:** در Validate **حتماً رقم بررسی را از محاسبه حذف کن**؛ یعنی فقط prefix استفاده شود.\n"
    },
    {
      "kind": "example",
      "text": "?? \"12345\" ?? ??????? [2,1] ? ??? ????? 6."
    },
    {
      "kind": "complexity",
      "text": "**زمان (Time):**\n- **Build:** `O(n)` — یک گذر از همه ارقام کد\n- **Validate:** `O(n)` — یک گذر برای محاسبه مجدد + مقایسه\n- هیچ حلقه تو در تو نداریم\n\n**حافظه (Space):**\n- `O(1)` — فقط چند متغیر: `sum`, `rest`, `check`, `i`\n- وزن‌ها معمولاً ثابت و کوچک هستند (مثلاً `[2, 1]` یا `[10..2]`)\n- الگوریتم In-Place نیست (رشته جدید برمی‌گردانیم)، ولی فضای اضافی مینیمال است\n\n**مقایسه با الگوریتم‌های دیگر:**\n- سریع‌تر از هش‌های رمزنگاری (MD5, SHA)\n- ساده‌تر از CRC (Cyclic Redundancy Check)\n- **کاربرد:** تشخیص خطای ساده، نه امنیت قوی\n\n**نکته امتحانی:**\n- همیشه `O(n)` است چون باید همه ارقام را ببینیم\n- نمی‌توان سریع‌تر از `O(n)` بود (باید کل کد را پردازش کنیم)\n"
    },
    {
      "kind": "ihk_traps",
      "text": "**1) فرمول نهایی اشتباه:**\n- ❌ `check = sum % 10` (غلط!)\n- ✓ `check = (10 - sum % 10) % 10` (درست)\n- دلیل: مدولو دوم تضمین می‌کند وقتی `sum % 10 = 0`، نتیجه 0 باشد (نه 10)\n\n**2) تبدیل char به int اشتباه:**\n- ❌ `digit = ord(c)` (کد ASCII برمی‌گرداند، مثلاً 48 برای '0')\n- ✓ `digit = int(c)` یا `digit = ord(c) - ord('0')`\n\n**3) اندیس وزن اشتباه:**\n- ❌ `weight = weights[i+1]` (ممکن است از محدوده خارج شود)\n- ✓ `weight = weights[i % len(weights)]` (تناوب)\n\n**4) در Validate: گنجاندن رقم بررسی در محاسبه:**\n- ❌ استفاده از `code` برای محاسبه (شامل رقم بررسی)\n- ✓ استفاده از `prefix = code[:-1]` (فقط ارقام اصلی)\n\n**5) مدولو اشتباه (Mod-10 vs Mod-11):**\n- Mod-10: برای بیشتر استانداردها (EAN, UPC, Luhn)\n- Mod-11: برای ISBN-10\n- ❌ استفاده از Mod-10 برای ISBN-10\n- ✓ بررسی دقیق استاندارد\n\n**6) Luhn: شروع از موقعیت اشتباه:**\n- ✓ شروع از راست به چپ (آخرین رقم = موقعیت 1)\n- ✓ فقط ارقام زوج (2، 4، 6...) دو برابر می‌شوند\n- ❌ شروع از چپ به راست\n\n**7) Luhn: فراموش کردن Quersumme برای doubled > 9:**\n- اگر `doubled = 16`:\n  - ❌ استفاده از 16 مستقیماً\n  - ✓ `1 + 6 = 7` یا `doubled - 9 = 7`\n\n**8) ISBN-10: فراموش کردن 'X' برای check = 10:**\n- ✓ اگر `(11 - sum % 11) % 11 = 10` → برگردان `'X'`\n- ❌ برگرداندن `'10'` یا `10`\n\n**9) عدم بررسی ورودی:**\n- ❌ فرض اینکه همه کاراکترها رقم هستند\n- ✓ بررسی `c.isdigit()` قبل از `int(c)`\n\n**10) وزن‌های ثابت vs متغیر:**\n- EAN-13: وزن‌های متناوب `[1, 3]`\n- ISBN-10: وزن‌های کاهشی `[10, 9, 8, ...]`\n- ❌ استفاده از وزن‌های اشتباه برای استاندارد خاص\n"
    },
    {
      "kind": "variants",
      "text": "**checksum_sum_digits**\n???: ??????? ??? ????? ??????.\nPseudocode: `ChecksumSumDigits(code)`.\n???????: `O(n)`, Space `O(1)`.\n??????:\n- ?????? ?? ?? ??? ????? ??? ?? ??? ???????.\n- ?? ??? ???? ???/?? ?????.\n\n**checksum_mod_10**\n???: ??????? ??? ????? Mod-10 ???? ???????.\nPseudocode: `CheckDigitMod10(code)`.\n???????: `O(n)`, Space `O(1)`.\n??????:\n- ????? `(10 - (sum % 10)) % 10` ?? ???? ???.\n- ????? ??? ????? ???? ?? sum.\n\n**checksum_weighted_mod_11**\n???: ??? ????? Mod-11 ??????? (??? ISBN-10).\nPseudocode: `CheckDigitMod11Weighted(code, weights)`.\n???????: `O(n)`, Space `O(1)`.\n??????:\n- ????? ?????? ???? ????.\n- Mod-11 ?? Mod-10 ?????? ????.\n\n**checksum_luhn_like**\n???: ????? ???? Luhn ?? ??????? ???? ??????.\nPseudocode: `CheckDigitLuhnLike(code)`.\n???????: `O(n)`, Space `O(1)`.\n??????:\n- ?? ???? ????? ??? ?? ????? ??? ??????? ???.\n- ??? >9 ??? 9 ?? ??.\n\n**checksum_build_and_validate**\n???: ???? ??? ????? ? ?????????? ?? ????.\nPseudocode: `BuildCodeWithCheck(code)` / `ValidateCode(fullCode)`.\n???????: ?? ???? `O(n)`, Space `O(1)`.\n??????:\n- ??? ????? ????? ??? ???.\n- expected ?? ?? ??? ???? ??? ????? ????.\n\n**checksum_weighted_alternating**\n???: ??????? ?????? 3/1 (EAN/UPC).\nPseudocode: `CheckDigitAlternating(code)`.\n???????: `O(n)`, Space `O(1)`.\n??????:\n- ??? ???? ?? ???? ?? ?????? ???.\n- mod-10 ????? ?????? ????.\n"
    }
  ]
}
